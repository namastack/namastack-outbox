package io.namastack.outbox.handler.method.internal

import org.springframework.aop.support.AopUtils
import org.springframework.core.annotation.AnnotatedElementUtils
import java.lang.reflect.Method

/**
 * Utility object for common reflection operations on handler methods.
 *
 * Provides reusable functions for:
 * - Resolving target classes behind AOP proxies
 * - Finding methods with specific signatures
 *
 * @author Roland Beisel
 * @since 1.0.0
 */
internal object ReflectionUtils {
    /**
     * Resolves the actual class of the given bean.
     *
     * If the bean is an AOP proxy (e.g., for @Transactional), retrieves the target class
     * behind the proxy. Otherwise, returns the bean's own class.
     *
     * This is necessary because AOP proxies wrap the actual bean implementation,
     * and we need to access the real implementation class to find the correct methods.
     *
     * @param bean The object instance whose class is to be resolved
     * @return The resolved Java class of the bean or its target class
     */
    fun getTargetClass(bean: Any): Class<*> =
        if (AopUtils.isAopProxy(bean)) {
            AopUtils.getTargetClass(bean)
        } else {
            bean::class.java
        }

    /**
     * Finds a method on the given bean with the specified name and parameter count.
     *
     * Filters out bridge and synthetic methods that are generated by the compiler.
     * Returns the first matching method found.
     *
     * @param bean The bean instance to search for the method
     * @param methodName The name of the method to find
     * @param parameterCount The number of parameters the method should have
     * @return The found Method object
     * @throws NoSuchElementException if no matching method is found
     */
    fun findMethod(
        bean: Any,
        methodName: String,
        parameterCount: Int,
    ): Method {
        val targetClass = getTargetClass(bean)
        return targetClass.methods
            .filter { !it.isBridge && !it.isSynthetic }
            .first { it.name == methodName && it.parameterCount == parameterCount }
    }

    /**
     * Finds all methods on the given bean that are annotated with the specified annotation.
     *
     * Filters out bridge and synthetic methods that are generated by the compiler.
     * Uses Spring's AnnotatedElementUtils to search for annotations in the method hierarchy
     * (class, interfaces, superclasses, meta-annotations).
     *
     * Example:
     * ```kotlin
     * val handlerMethods = ReflectionUtils.findAnnotatedMethods(bean, OutboxHandler::class.java)
     * ```
     *
     * @param bean The bean instance to search for annotated methods
     * @param annotationClass The annotation class to search for
     * @return Sequence of methods annotated with the specified annotation
     */
    fun <A : Annotation> findAnnotatedMethods(
        bean: Any,
        annotationClass: Class<A>,
    ): Sequence<Method> {
        val targetClass = getTargetClass(bean)
        return targetClass.methods
            .asSequence()
            .filterNot { it.isBridge && it.isSynthetic }
            .filter { AnnotatedElementUtils.findMergedAnnotation(it, annotationClass) != null }
    }
}
