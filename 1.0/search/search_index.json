{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"Getting Started  View on GitHub"},{"location":"#welcome","title":"Welcome!","text":""},{"location":"#why-should-you-use-namastack-outbox-for-spring-boot","title":"Why should you use Namastack Outbox for Spring Boot?","text":"<ul> <li> <p> Reliable Event Delivery</p> <p>Ensure each event is delivered at least once, even if failures occur. Retries and transactional storage guarantee no events are lost.</p> </li> <li> <p> Consistent State and Messages</p> <p>Keep your database and message broker in sync by storing events within the same transaction as your business data.</p> </li> <li> <p> Asynchronous Scalability</p> <p>Offload message publishing to a background process, allowing your main workflow to remain fast and responsive.</p> </li> <li> <p> Simple and Transparent</p> <p>Designed for simplicity \u2014 no complex infrastructure required. Just use your database and a reliable message dispatcher.</p> </li> <li> <p> Observability and Monitoring</p> <p>Track the status of your outbox events and failures with metrics, logs, and dashboards, making it easier to debug and operate reliably.</p> </li> <li> <p> Transactional Safety</p> <p>Outbox ensures your business operations are atomic \u2014 either both the database update and message dispatch succeed, or neither does.</p> </li> </ul>"},{"location":"#how-it-works","title":"How It Works","text":"<p>Namastack Outbox for Spring Boot brings bulletproof reliability to your event-driven systems \u2014 combining transactional integrity with seamless message delivery.</p> <p>When your application writes data, both the entity table and the outbox table are updated within a single ACID transaction. This guarantees that your domain state and outgoing events are always consistent \u2014 even if the system crashes mid-operation.</p> <p>A background outbox scheduler polls the database for new outbox records and hands them off to your custom outbox processor \u2014 a lightweight interface you implement to publish messages to your broker (e.g. Kafka, RabbitMQ, SNS).</p> <p>Once messages are successfully delivered, they\u2019re marked as processed. This architecture ensures:</p> <ul> <li>Zero message loss, even under failure</li> <li>Strict per-aggregate ordering for deterministic processing</li> <li>Horizontal scalability with hash-based partitioning</li> <li>At-least-once delivery with safe retry policies and observability</li> </ul> <p>With Namastack Outbox for Spring Boot, you get the reliability of database transactions \u2014 and the resilience of message-driven design. Build confidently, scale safely, and never lose an event again.</p>"},{"location":"features/","title":"Features","text":"<p>Namastack Outbox for Spring Boot provides a comprehensive set of features to implement the Outbox  Pattern in distributed systems with reliability, scalability, and ease of use.</p>"},{"location":"features/#core-features","title":"Core Features","text":""},{"location":"features/#transactional-outbox-pattern","title":"Transactional Outbox Pattern","text":"<p>Zero Message Loss</p> <p>The library ensures that domain records are never lost by storing them in the same database transaction as your business data. This guarantees consistency between your domain state and persisted records.</p>"},{"location":"features/#benefits","title":"Benefits","text":"<ul> <li>ACID Compliance: Records are saved atomically with business data</li> <li>Consistency Guarantee: No partial updates or lost records</li> <li>Failure Recovery: System crashes don't result in data loss</li> <li>Reliable Processing: Records are processed with automatic retry logic</li> </ul>"},{"location":"features/#how-it-works","title":"How it Works","text":"<pre><code>sequenceDiagram\n    participant A as Application\n    participant DB as Entity Table\n    participant O as Outbox Table\n    participant S as Scheduler\n    participant P as Handler\n\n    A-&gt;&gt;DB: Begin Transaction\n    A-&gt;&gt;DB: Save Business Data\n    A-&gt;&gt;O: Save Record\n    DB-&gt;&gt;A: Commit Transaction\n    S-&gt;&gt;O: Poll Records\n    S-&gt;&gt;P: Invoke Handler\n    P-&gt;&gt;P: Process Record\n    S-&gt;&gt;O: Mark Complete</code></pre>"},{"location":"features/#record-ordering","title":"Record Ordering","text":"<p>Guaranteed Processing Order</p> <p>Records with the same key are always processed in creation order, ensuring business logic consistency and preventing race conditions.</p> <p>Key Benefits:</p> <ul> <li> Aggregate Consistency: Records with the same key maintain order</li> <li> Business Logic Safety: Dependent records process in correct sequence  </li> <li> Parallel Processing: Different keys process independently</li> <li> Scalable Design: No global ordering bottlenecks</li> </ul>"},{"location":"features/#controlling-failure-behavior","title":"Controlling Failure Behavior","text":"<p>Control how the scheduler handles failures within a key sequence:</p> <p>Stop on First Failure Configuration</p> Enabled (Default)Disabled <pre><code>namastack:\n  outbox:\n    processing:\n      stop-on-first-failure: true\n</code></pre> <p>Behavior: - When one record fails, processing stops for remaining records with the same key - Maintains strict ordering within key sequences - Prevents cascading issues from dependent records - Recommended: When records within a key have dependencies</p> <pre><code>namastack:\n  outbox:\n    processing:\n      stop-on-first-failure: false\n</code></pre> <p>Behavior: - Failed records don't block independent records with the same key - Maximizes throughput for independent records - Recommended: When records within a key are independent</p> <p>Behavior Comparison:</p> Configuration Record 1 Record 2 Record 3 Result <code>true</code> (default)  Success  Fails  Skipped Record 2 retried, Record 3 waits <code>false</code>  Success  Fails  Success Record 2 retried independently"},{"location":"features/#hash-based-partitioning","title":"Hash-based Partitioning","text":"<p>Instead of distributed locking, the library uses hash-based partitioning to enable horizontal scaling across multiple instances while maintaining strict record ordering per key. This approach eliminates lock contention and provides better performance.</p>"},{"location":"features/#how-partitioning-works","title":"How Partitioning Works","text":"<pre><code>graph TB\n    A[\"Key: order-123\"] --&gt; H[MurmurHash3]\n    H --&gt; P[Partition 42]\n    P --&gt; I1[Instance 1]\n\n    B[\"Key: user-456\"] --&gt; H2[MurmurHash3]\n    H2 --&gt; P2[Partition 128]\n    P2 --&gt; I2[Instance 2]\n\n    C[\"Key: order-789\"] --&gt; H3[MurmurHash3]\n    H3 --&gt; P3[Partition 42]\n    P3 --&gt; I1\n\n    subgraph \"256 Fixed Partitions\"\n        P\n        P2\n        P3[\"...other partitions\"]\n    end\n\n    subgraph \"Dynamic Instance Assignment\"\n        I1[\"Instance 1: Partitions 0-127\"]\n        I2[\"Instance 2: Partitions 128-255\"]\n    end</code></pre>"},{"location":"features/#key-benefits","title":"Key Benefits","text":"<ul> <li>Consistent Hashing: Each key always maps to the same partition using MurmurHash3</li> <li>No Lock Contention: Eliminates distributed lock overhead and deadlock risks</li> <li>Horizontal Scaling: Partitions automatically redistribute when instances join/leave</li> <li>Load Balancing: Even distribution of partitions across all active instances</li> <li>Ordering Guarantee: Records within the same key process in strict order</li> <li>Better Performance: No lock acquisition/renewal overhead</li> </ul>"},{"location":"features/#partition-assignment","title":"Partition Assignment","text":"<p>256 fixed partitions provide fine-grained load distribution. Partitions are automatically distributed among active instances. Each key always maps to the same partition.</p> KotlinJava <pre><code>val partition = PartitionHasher.getPartitionForAggregate(\"order-123\")\n</code></pre> <pre><code>int partition = PartitionHasher.getPartitionForAggregate(\"order-123\");\n</code></pre>"},{"location":"features/#instance-coordination","title":"Instance Coordination","text":"<p>Instances automatically coordinate partition assignments and rebalance when topology changes. Configuration controls how aggressive this coordination is:</p> <pre><code>namastack:\n  outbox:\n    instance:\n      heartbeat-interval-seconds: 5            # How often each instance sends a heartbeat\n      stale-instance-timeout-seconds: 30       # When an instance is considered stale and removed\n      graceful-shutdown-timeout-seconds: 0     # Optional: propagation window on shutdown (default: 0)\n      rebalance-interval: 10000                # How often partitions are recalculated\n</code></pre> <p>Scaling Behavior</p> 3 Instances with 256 PartitionsInstance 2 Goes DownNew Instance Joins <pre><code>Instance 1: Partitions 0-84   (85 partitions)\nInstance 2: Partitions 85-169 (85 partitions) \nInstance 3: Partitions 170-255 (86 partitions)\n</code></pre> <pre><code>Instance 1: Partitions 0-84, 170-211   (127 partitions)\nInstance 3: Partitions 85-169, 212-255 (129 partitions)\n</code></pre> <p>\ud83d\udd04 Automatic Rebalancing: Partitions from failed instances are redistributed</p> <pre><code>Instance 1: Partitions 0-63    (64 partitions)\nInstance 2: Partitions 64-127  (64 partitions)\nInstance 3: Partitions 128-191 (64 partitions)\nInstance 4: Partitions 192-255 (64 partitions)\n</code></pre> <p>\u2696\ufe0f Load Balancing: Partitions are redistributed evenly</p>"},{"location":"features/#record-scheduling","title":"Record Scheduling","text":""},{"location":"features/#outbox-service-api","title":"Outbox Service API","text":"<p>Schedule records for processing via the <code>Outbox</code> service:</p> KotlinJava <pre><code>@Service\nclass OrderService(\n    private val outbox: Outbox,\n    private val orderRepository: OrderRepository\n) {\n    @Transactional\n    fun createOrder(command: CreateOrderCommand) {\n        val order = Order.create(command)\n        orderRepository.save(order)\n\n        // Schedule record with explicit key\n        outbox.schedule(\n            payload = OrderCreatedRecord(order.id, order.customerId),\n            key = \"order-${order.id}\"  // Groups records for ordered processing\n        )\n    }\n\n    @Transactional\n    fun updateOrder(orderId: String) {\n        // Schedule record with auto-generated UUID key\n        outbox.schedule(payload = OrderUpdatedRecord(orderId))\n    }\n}\n</code></pre> <pre><code>@Service\npublic class OrderService {\n    private final Outbox outbox;\n    private final OrderRepository orderRepository;\n\n    public OrderService(Outbox outbox, OrderRepository orderRepository) {\n        this.outbox = outbox;\n        this.orderRepository = orderRepository;\n    }\n\n    @Transactional\n    public void createOrder(CreateOrderCommand command) {\n        Order order = Order.create(command);\n        orderRepository.save(order);\n\n        // Schedule record with explicit key\n        outbox.schedule(\n            new OrderCreatedRecord(order.getId(), order.getCustomerId()),\n            \"order-\" + order.getId()  // Groups records for ordered processing\n        );\n    }\n\n    @Transactional\n    public void updateOrder(String orderId) {\n        // Schedule record with auto-generated UUID key\n        outbox.schedule(new OrderUpdatedRecord(orderId));\n    }\n}\n</code></pre>"},{"location":"features/#record-lifecycle","title":"Record Lifecycle","text":"<p>Records go through the following states:</p> <ul> <li>NEW: Freshly scheduled, waiting for processing</li> <li>COMPLETED: Successfully processed by all handlers</li> <li>FAILED: Exhausted all retries, requires manual intervention</li> </ul>"},{"location":"features/#outboxeventmulticaster","title":"OutboxEventMulticaster","text":"<p>The <code>OutboxEventMulticaster</code> provides seamless integration with Spring's event system. It automatically intercepts and persists events annotated with <code>@OutboxEvent</code> directly to the outbox table, allowing you to use Spring's native <code>ApplicationEventPublisher</code> while getting outbox benefits.</p>"},{"location":"features/#how-it-works_1","title":"How It Works","text":"<pre><code>graph TB\n    A[\"publishEvent(event)\"] --&gt; B[\"OutboxEventMulticaster\"]\n    B --&gt; C{Check OutboxEvent&lt;br/&gt;Annotation}\n    C --&gt;|Present| D[\"Serialize &amp; Store\"]\n    C --&gt;|Not Present| E[\"Normal Event Flow\"]\n    D --&gt; F[\"Outbox Table\"]\n    E --&gt; G[\"Event Listeners\"]\n    D --&gt;|if publish-after-save=true| G</code></pre>"},{"location":"features/#outboxevent-annotation","title":"@OutboxEvent Annotation","text":"<p>Mark your events with <code>@OutboxEvent</code> to enable automatic outbox persistence:</p> KotlinJava <pre><code>@OutboxEvent(key = \"#event.orderId\")  // SpEL expression for key resolution\ndata class OrderCreatedEvent(\n    val orderId: String,\n    val customerId: String,\n    val amount: BigDecimal\n)\n</code></pre> <pre><code>@OutboxEvent(key = \"#event.orderId\")  // SpEL expression for key resolution\npublic class OrderCreatedEvent {\n    private String orderId;\n    private String customerId;\n    private BigDecimal amount;\n\n    // constructor, getters, setters...\n}\n</code></pre>"},{"location":"features/#spel-key-resolution","title":"SpEL Key Resolution","text":"<p>The <code>key</code> parameter supports Spring Expression Language (SpEL) for dynamic key extraction:</p> Expression Description Example <code>#root.fieldName</code> Access root object property <code>#root.orderId</code> <code>#event.fieldName</code> Same as #root (alternative syntax) <code>#event.customerId</code> <code>#root.getId()</code> Call method on root object <code>#root.getOrderId()</code> <code>#root.nested.field</code> Access nested properties <code>#root.order.id</code> <code>#root.toString()</code> Convert to string <code>#root.id.toString()</code> <p>SpEL Examples</p> Simple PropertyMethod CallNested Property <pre><code>@OutboxEvent(key = \"#event.orderId\")\ndata class OrderEvent(val orderId: String)\n</code></pre> <pre><code>@OutboxEvent(key = \"#event.getAggregateId()\")\ndata class DomainEvent(val id: UUID) {\n    fun getAggregateId() = id.toString()\n}\n</code></pre> <pre><code>@OutboxEvent(key = \"#event.order.id\")\ndata class OrderConfirmedEvent(val order: Order)\n</code></pre>"},{"location":"features/#configuration","title":"Configuration","text":"<p>The multicaster can be configured to control event publishing behavior:</p> <pre><code>namastack:\n  outbox:\n    multicaster:\n      enabled: true  # Enable/disable automatic interception (default: true)\n\n    processing:\n      publish-after-save: true  # Also forward to other listeners in same transaction (default: true)\n</code></pre> Configuration Value Effect <code>multicaster.enabled</code> <code>true</code> (default) @OutboxEvent annotations are intercepted and stored <code>multicaster.enabled</code> <code>false</code> OutboxEventMulticaster is disabled, events flow normally <code>publish-after-save</code> <code>true</code> (default) Events also published to other listeners in same transaction <code>publish-after-save</code> <code>false</code> Events only stored to outbox, not published to listeners"},{"location":"features/#usage-example","title":"Usage Example","text":"KotlinJava <pre><code>@Service\nclass OrderService(\n    private val orderRepository: OrderRepository,\n    private val eventPublisher: ApplicationEventPublisher\n) {\n    @Transactional\n    fun createOrder(command: CreateOrderCommand) {\n        val order = Order.create(command)\n        orderRepository.save(order)\n\n        // Automatically saved to outbox + published to listeners\n        eventPublisher.publishEvent(\n            OrderCreatedEvent(order.id, order.customerId, order.amount)\n        )\n    }\n}\n</code></pre> <pre><code>@Service\npublic class OrderService {\n    private final OrderRepository orderRepository;\n    private final ApplicationEventPublisher eventPublisher;\n\n    public OrderService(OrderRepository orderRepository, \n                       ApplicationEventPublisher eventPublisher) {\n        this.orderRepository = orderRepository;\n        this.eventPublisher = eventPublisher;\n    }\n\n    @Transactional\n    public void createOrder(CreateOrderCommand command) {\n        Order order = Order.create(command);\n        orderRepository.save(order);\n\n        // Automatically saved to outbox + published to listeners\n        eventPublisher.publishEvent(\n            new OrderCreatedEvent(order.getId(), order.getCustomerId(), order.getAmount())\n        );\n    }\n}\n</code></pre>"},{"location":"features/#outboxevent-with-context","title":"@OutboxEvent with Context","text":"<p>When using <code>@OutboxEvent</code> with <code>ApplicationEventPublisher</code>, you can define context using SpEL expressions:</p> KotlinJava <pre><code>@OutboxEvent(\n    key = \"#this.orderId\",\n    context = [\n        OutboxContextEntry(key = \"customerId\", value = \"#this.customerId\"),\n        OutboxContextEntry(key = \"region\", value = \"#this.region\"),\n        OutboxContextEntry(key = \"priority\", value = \"#this.priority\")\n    ]\n)\ndata class OrderCreatedEvent(\n    val orderId: String,\n    val customerId: String,\n    val region: String,\n    val priority: String\n)\n</code></pre> <pre><code>@OutboxEvent(\n    key = \"#this.orderId\",\n    context = {\n        @OutboxContextEntry(key = \"customerId\", value = \"#this.customerId\"),\n        @OutboxContextEntry(key = \"region\", value = \"#this.region\"),\n        @OutboxContextEntry(key = \"priority\", value = \"#this.priority\")\n    }\n)\npublic class OrderCreatedEvent {\n    private String orderId;\n    private String customerId;\n    private String region;\n    private String priority;\n    // constructor, getters...\n}\n</code></pre> <p>Context from <code>@OutboxEvent</code> annotations is merged with context from registered <code>OutboxContextProvider</code> beans.</p>"},{"location":"features/#processing-chain","title":"Processing Chain","text":"<p>Internal Processing Pipeline</p> <p>The library uses a Chain of Responsibility pattern to process outbox records through multiple stages. Each processor in the chain handles a specific concern and can delegate to the next processor when needed.</p>"},{"location":"features/#chain-architecture","title":"Chain Architecture","text":"<p>The processing chain consists of four processors, executed in this exact order:</p> <pre><code>flowchart LR\n    A((Start)) --&gt; B[Invoke Handler]\n    B --&gt; C{Success?}\n\n    C -- Yes --&gt; Z[Mark COMPLETED]\n    C -- No --&gt; D{Can Retry?}\n\n    D -- Yes --&gt; E[Schedule Retry]\n\n    D -- No --&gt; F{Fallback Exists?}\n\n    F -- Yes --&gt; G[Invoke Fallback]\n    G --&gt; H{Fallback Success?}\n\n    H -- Yes --&gt; Z\n    H -- No --&gt; Y[Mark FAILED]\n\n    F -- No --&gt; Y\n\n    Y --&gt; S((Stop))\n    Z --&gt; S((Stop))</code></pre> <p>Processing Flow:</p> <ol> <li> <p>Primary Handler Processor - Invokes the registered handler for the payload type. On success, marks record as <code>COMPLETED</code>. On exception, passes to Retry Processor.</p> </li> <li> <p>Retry Processor - Evaluates if the exception is retryable and if retry limit is not exceeded. Schedules next retry with calculated delay or passes to Fallback Processor.</p> </li> <li> <p>Fallback Processor - Invokes registered fallback handler if available. On success, marks record as <code>COMPLETED</code>. On failure or if no fallback exists, passes to Permanent Failure Processor.</p> </li> <li> <p>Permanent Failure Processor - Marks the record as permanently <code>FAILED</code>. Final state - no further processing.</p> </li> </ol>"},{"location":"features/#processing-flow-examples","title":"Processing Flow Examples","text":""},{"location":"features/#scenario-1-retries-exhausted-with-successful-fallback","title":"Scenario 1: Retries Exhausted with Successful Fallback","text":"<p>Order processing with 3 max retries and fallback handler:</p> <pre><code>sequenceDiagram\n    participant S as Scheduler\n    participant P as Primary Processor\n    participant R as Retry Processor\n    participant F as Fallback Processor\n    participant DB as Database\n\n    Note over S,DB: Attempts 1-3: Retries\n    loop 3 times\n        S-&gt;&gt;P: Process Record\n        P-&gt;&gt;P: SocketTimeoutException\n        P-&gt;&gt;R: Handle Exception\n        R-&gt;&gt;R: Can Retry? \u2713\n        R-&gt;&gt;DB: Schedule Retry (1s\u21922s\u21924s)\n    end\n\n    Note over S,DB: Attempt 4: Fallback\n    S-&gt;&gt;P: Process Record\n    P-&gt;&gt;P: SocketTimeoutException\n    P-&gt;&gt;R: Handle Exception\n    R-&gt;&gt;R: Retries Exhausted\n    R-&gt;&gt;F: Invoke Fallback\n    F-&gt;&gt;F: Publish to DLQ\n    F-&gt;&gt;DB: Mark COMPLETED \u2713</code></pre>"},{"location":"features/#scenario-2-non-retryable-exception","title":"Scenario 2: Non-Retryable Exception","text":"<p>Order processing with non-retryable exception:</p> <pre><code>sequenceDiagram\n    participant S as Scheduler\n    participant P as Primary Processor\n    participant R as Retry Processor\n    participant F as Fallback Processor\n    participant DB as Database\n\n    S-&gt;&gt;P: Process Record\n    P-&gt;&gt;P: IllegalArgumentException\n    P-&gt;&gt;R: Handle Exception\n    R-&gt;&gt;R: Non-Retryable Exception\n    R-&gt;&gt;F: Invoke Fallback\n    F-&gt;&gt;F: Publish to DLQ\n    F-&gt;&gt;DB: Mark COMPLETED \u2713</code></pre>"},{"location":"features/#scenario-3-no-fallback-handler","title":"Scenario 3: No Fallback Handler","text":"<p>Order processing without fallback handler:</p> <pre><code>sequenceDiagram\n    participant S as Scheduler\n    participant P as Primary Processor\n    participant R as Retry Processor\n    participant F as Fallback Processor\n    participant PF as Permanent Failure Processor\n    participant DB as Database\n\n    Note over S,DB: Attempts 1-3: Retries\n    loop 3 times\n        S-&gt;&gt;P: Process Record\n        P-&gt;&gt;P: SocketTimeoutException\n        P-&gt;&gt;R: Handle Exception\n        R-&gt;&gt;R: Can Retry? \u2713\n        R-&gt;&gt;DB: Schedule Retry (1s\u21922s\u21924s)\n    end\n\n    Note over S,DB: Attempt 4: Permanent Failure\n    S-&gt;&gt;P: Process Record\n    P-&gt;&gt;P: SocketTimeoutException\n    P-&gt;&gt;R: Handle Exception\n    R-&gt;&gt;R: Retries Exhausted\n    R-&gt;&gt;F: Check Fallback\n    F-&gt;&gt;F: No Fallback Found\n    F-&gt;&gt;PF: Handle Permanent Failure\n    PF-&gt;&gt;DB: Mark FAILED \u2717</code></pre>"},{"location":"features/#handlers","title":"Handlers","text":""},{"location":"features/#handler-types-interfaces","title":"Handler Types &amp; Interfaces","text":"<p>The library provides two complementary handler interfaces for different use cases:</p>"},{"location":"features/#typed-handlers-type-safe","title":"Typed Handlers (Type-Safe)","text":"<p>Process specific payload types with full type safety. Recommended for most cases as handlers are type-checked at compile time.</p> KotlinJava <pre><code>@Component\nclass OrderCreatedHandler : OutboxTypedHandler&lt;OrderCreatedRecord&gt; {\n    override fun handle(payload: OrderCreatedRecord) {\n        println(\"Processing order: ${payload.orderId}\")\n        eventPublisher.publish(payload)\n    }\n}\n</code></pre> <pre><code>@Component\npublic class OrderCreatedHandler implements OutboxTypedHandler&lt;OrderCreatedRecord&gt; {\n    @Override\n    public void handle(OrderCreatedRecord payload) {\n        System.out.println(\"Processing order: \" + payload.getOrderId());\n        eventPublisher.publish(payload);\n    }\n}\n</code></pre>"},{"location":"features/#generic-handlers-multi-type","title":"Generic Handlers (Multi-Type)","text":"<p>Process any payload type with pattern matching. Use for catch-all or multi-type routing logic.</p> KotlinJava <pre><code>@Component\nclass UniversalHandler : OutboxHandler {\n    override fun handle(payload: Any, metadata: OutboxRecordMetadata) {\n        when (payload) {\n            is OrderCreatedRecord -&gt; handleOrder(payload)\n            is PaymentProcessedRecord -&gt; handlePayment(payload)\n            is CreateCustomerCommand -&gt; createCustomer(payload)\n            else -&gt; logger.warn(\"Unknown payload: ${payload::class.simpleName}\")\n        }\n    }\n}\n</code></pre> <pre><code>@Component\npublic class UniversalHandler implements OutboxHandler {\n    @Override\n    public void handle(Object payload, OutboxRecordMetadata metadata) {\n        if (payload instanceof OrderCreatedRecord) {\n            handleOrder((OrderCreatedRecord) payload);\n        } else if (payload instanceof PaymentProcessedRecord) {\n            handlePayment((PaymentProcessedRecord) payload);\n        } else if (payload instanceof CreateCustomerCommand) {\n            createCustomer((CreateCustomerCommand) payload);\n        } else {\n            logger.warn(\"Unknown payload: {}\", payload.getClass().getSimpleName());\n        }\n    }\n}\n</code></pre>"},{"location":"features/#handler-invocation-order","title":"Handler Invocation Order","text":"<p>When multiple handlers are registered:</p> <ol> <li>All matching typed handlers are invoked first (in registration order)</li> <li>All generic handlers are invoked second (catch-all)</li> </ol>"},{"location":"features/#annotation-based-handlers","title":"Annotation-based Handlers","text":"<p>Use <code>@OutboxHandler</code> annotation for method-level handler registration as an alternative to implementing interfaces:</p> KotlinJava <pre><code>@Component\nclass MyHandlers {\n    @OutboxHandler\n    fun handleOrderCreated(payload: OrderCreatedRecord) {\n        // ...\n    }\n\n    @OutboxHandler\n    fun handlePaymentProcessed(payload: PaymentProcessedRecord) {\n        // ...\n    }\n\n    @OutboxHandler\n    fun handleAny(payload: Any, metadata: OutboxRecordMetadata) {\n        // Generic handler via annotation\n    }\n}\n</code></pre> <pre><code>@Component\npublic class MyHandlers {\n    @OutboxHandler\n    public void handleOrderCreated(OrderCreatedRecord payload) {\n        // ...\n    }\n\n    @OutboxHandler\n    public void handlePaymentProcessed(PaymentProcessedRecord payload) {\n        // ...\n    }\n\n    @OutboxHandler\n    public void handleAny(Object payload, OutboxRecordMetadata metadata) {\n        // Generic handler via annotation\n    }\n}\n</code></pre> <p>Handler Signature Requirements</p> <ul> <li>Typed handlers can accept 1 or 2 parameters:</li> <li><code>fun handle(payload: T)</code> - Payload only</li> <li><code>fun handle(payload: T, metadata: OutboxRecordMetadata)</code> - Payload + metadata</li> <li>Generic handlers must accept 2 parameters:</li> <li><code>fun handle(payload: Any, metadata: OutboxRecordMetadata)</code> - Required signature</li> </ul> <p>Interface vs Annotation: - Interfaces: Best when entire class is dedicated to handling a single type - Annotations: Best when a class handles multiple types or mixing with other logic</p>"},{"location":"features/#fallback-handlers","title":"Fallback Handlers","text":"<p>Graceful Degradation (Since 1.0.0)</p> <p>Fallback handlers provide a safety net when all retries are exhausted, allowing for compensating actions, dead letter queue publishing, or alternative processing strategies.</p> <p>Fallback handlers are automatically invoked when:</p> <ul> <li>Retries Exhausted: The record has exceeded the maximum retry count</li> <li>Non-Retryable Exceptions: An exception is thrown that should not be retried (based on retry policy)</li> </ul>"},{"location":"features/#interface-based-fallback-handlers","title":"Interface-Based Fallback Handlers","text":"<p>Implement <code>OutboxFallbackHandler</code> interface for type-safe fallback handling:</p> KotlinJava <pre><code>@Component\nclass OrderFallbackHandler : OutboxFallbackHandler&lt;OrderEvent&gt; {\n    override fun handle(payload: OrderEvent, context: OutboxFailureContext) {\n        logger.error(\n            \"Order ${payload.orderId} failed permanently after ${context.failureCount} attempts\",\n            context.lastException\n        )\n\n        // Publish to dead letter queue\n        deadLetterQueue.publish(\n            payload = payload,\n            reason = \"Max retries exceeded\",\n            exception = context.lastException,\n            traceId = context.context[\"traceId\"]\n        )\n\n        // Send alert\n        alertService.sendAlert(\n            \"Order processing failed permanently: ${payload.orderId}\"\n        )\n    }\n}\n</code></pre> <pre><code>@Component\npublic class OrderFallbackHandler implements OutboxFallbackHandler&lt;OrderEvent&gt; {\n    @Override\n    public void handle(OrderEvent payload, OutboxFailureContext context) {\n        logger.error(\n            \"Order {} failed permanently after {} attempts\",\n            payload.getOrderId(),\n            context.getFailureCount(),\n            context.getLastException()\n        );\n\n        // Publish to dead letter queue\n        deadLetterQueue.publish(\n            payload,\n            \"Max retries exceeded\",\n            context.getLastException(),\n            context.getContext().get(\"traceId\")\n        );\n\n        // Send alert\n        alertService.sendAlert(\n            \"Order processing failed permanently: \" + payload.getOrderId()\n        );\n    }\n}\n</code></pre>"},{"location":"features/#annotation-based-fallback-handlers","title":"Annotation-Based Fallback Handlers","text":"<p>Use <code>@OutboxFallbackHandler</code> annotation for method-level fallback registration:</p> KotlinJava <pre><code>@Component\nclass OrderHandlers {\n    @OutboxHandler\n    fun handleOrder(payload: OrderEvent) {\n        emailService.send(payload.email)  // May fail\n    }\n\n    @OutboxFallbackHandler\n    fun handleOrderFailure(payload: OrderEvent, context: OutboxFailureContext) {\n        logger.error(\n            \"Order ${payload.orderId} failed after ${context.failureCount} attempts\"\n        )\n        deadLetterQueue.publish(payload)\n    }\n}\n</code></pre> <pre><code>@Component\npublic class OrderHandlers {\n    @OutboxHandler\n    public void handleOrder(OrderEvent payload) {\n        emailService.send(payload.getEmail());  // May fail\n    }\n\n    @OutboxFallbackHandler\n    public void handleOrderFailure(OrderEvent payload, OutboxFailureContext context) {\n        logger.error(\n            \"Order {} failed after {} attempts\",\n            payload.getOrderId(),\n            context.getFailureCount()\n        );\n        deadLetterQueue.publish(payload);\n    }\n}\n</code></pre>"},{"location":"features/#outboxfailurecontext","title":"OutboxFailureContext","text":"<p>The <code>OutboxFailureContext</code> provides comprehensive failure information:</p> <pre><code>interface OutboxFailureContext {\n    val handlerId: String              // Handler that failed\n    val key: String                    // Record key\n    val createdAt: Instant            // When record was created\n    val failureCount: Int             // Number of failed attempts\n    val lastException: Throwable?     // Last exception thrown\n    val context: Map&lt;String, String&gt;  // Propagated context (traceId, tenantId, etc.)\n}\n</code></pre>"},{"location":"features/#fallback-behavior","title":"Fallback Behavior","text":"<p>Record Status After Fallback:</p> <ul> <li>Fallback Succeeds: Record marked as <code>COMPLETED</code></li> <li>Fallback Fails: Record marked as <code>FAILED</code> (requires manual intervention)</li> </ul> <p>Automatic Matching:</p> <p>Fallback handlers are automatically matched to primary handlers by payload type. One fallback handler can serve multiple primary handlers processing the same payload type.</p> KotlinJava <pre><code>@Component\nclass OrderHandlers {\n    // Both handlers share the same fallback\n    @OutboxHandler\n    fun handleOrderCreated(payload: OrderEvent) {\n        orderService.create(payload)\n    }\n\n    @OutboxHandler\n    fun handleOrderUpdated(payload: OrderEvent) {\n        orderService.update(payload)\n    }\n\n    @OutboxFallbackHandler\n    fun handleOrderFailure(payload: OrderEvent, context: OutboxFailureContext) {\n        // Handles failures from both handleOrderCreated and handleOrderUpdated\n        deadLetterQueue.publish(payload)\n    }\n}\n</code></pre> <pre><code>@Component\npublic class OrderHandlers {\n    // Both handlers share the same fallback\n    @OutboxHandler\n    public void handleOrderCreated(OrderEvent payload) {\n        orderService.create(payload);\n    }\n\n    @OutboxHandler\n    public void handleOrderUpdated(OrderEvent payload) {\n        orderService.update(payload);\n    }\n\n    @OutboxFallbackHandler\n    public void handleOrderFailure(OrderEvent payload, OutboxFailureContext context) {\n        // Handles failures from both handleOrderCreated and handleOrderUpdated\n        deadLetterQueue.publish(payload);\n    }\n}\n</code></pre> <p>Fallback Handler Requirements</p> <ul> <li>Only one fallback handler per payload type is supported</li> <li>Fallback handlers must match the payload type exactly</li> <li>Fallback signature: <code>fun handle(payload: T, context: OutboxFailureContext)</code></li> </ul>"},{"location":"features/#use-cases","title":"Use Cases","text":"<p>Common use cases for fallback handlers:</p> <ol> <li>Dead Letter Queue: Publish failed records to a DLQ for later analysis</li> <li>Alert &amp; Monitoring: Send alerts when records fail permanently</li> <li>Compensating Actions: Execute compensating transactions (e.g., refund, rollback)</li> <li>Alternative Processing: Route to alternative processing logic</li> <li>Audit Logging: Log failure details for compliance and debugging</li> </ol>"},{"location":"features/#context-propagation","title":"Context Propagation","text":"<p>Cross-Boundary Context (Since 1.0.0)</p> <p>Context propagation preserves important metadata (trace IDs, tenant info, correlation IDs, user context) across the async boundary between scheduling and processing.</p>"},{"location":"features/#how-it-works_2","title":"How It Works","text":"<p>Context is captured when records are scheduled and restored when handlers are invoked:</p> <pre><code>sequenceDiagram\n    participant App as Application\n    participant CP as OutboxContextProvider\n    participant DB as Outbox Table\n    participant Scheduler as Scheduler\n    participant Handler as Handler\n\n    App-&gt;&gt;CP: Request current context\n    CP--&gt;&gt;App: {traceId, spanId, tenantId}\n    App-&gt;&gt;DB: Save record + context\n    Note over DB: Context stored as JSON\n\n    Scheduler-&gt;&gt;DB: Poll records\n    DB--&gt;&gt;Scheduler: Record + context\n    Scheduler-&gt;&gt;Handler: Invoke with metadata\n    Note over Handler: Context available via&lt;br/&gt;metadata.context</code></pre>"},{"location":"features/#outboxcontextprovider-interface","title":"OutboxContextProvider Interface","text":"<p>Implement <code>OutboxContextProvider</code> to capture context during record scheduling:</p> KotlinJava <pre><code>@Component\nclass TracingContextProvider(\n    private val tracer: Tracer\n) : OutboxContextProvider {\n    override fun provide(): Map&lt;String, String&gt; {\n        val currentSpan = tracer.currentSpan() ?: return emptyMap()\n        return mapOf(\n            \"traceId\" to currentSpan.context().traceId(),\n            \"spanId\" to currentSpan.context().spanId()\n        )\n    }\n}\n\n@Component\nclass TenantContextProvider : OutboxContextProvider {\n    override fun provide(): Map&lt;String, String&gt; {\n        val tenantId = SecurityContextHolder.getContext()\n            .authentication\n            ?.principal\n            ?.let { (it as? TenantAware)?.tenantId }\n            ?: return emptyMap()\n\n        return mapOf(\"tenantId\" to tenantId)\n    }\n}\n</code></pre> <pre><code>@Component\npublic class TracingContextProvider implements OutboxContextProvider {\n    private final Tracer tracer;\n\n    public TracingContextProvider(Tracer tracer) {\n        this.tracer = tracer;\n    }\n\n    @Override\n    public Map&lt;String, String&gt; provide() {\n        Span currentSpan = tracer.currentSpan();\n        if (currentSpan == null) {\n            return Collections.emptyMap();\n        }\n\n        return Map.of(\n            \"traceId\", currentSpan.context().traceId(),\n            \"spanId\", currentSpan.context().spanId()\n        );\n    }\n}\n\n@Component\npublic class TenantContextProvider implements OutboxContextProvider {\n    @Override\n    public Map&lt;String, String&gt; provide() {\n        Authentication auth = SecurityContextHolder.getContext().getAuthentication();\n        if (auth == null || !(auth.getPrincipal() instanceof TenantAware)) {\n            return Collections.emptyMap();\n        }\n\n        String tenantId = ((TenantAware) auth.getPrincipal()).getTenantId();\n        return Map.of(\"tenantId\", tenantId);\n    }\n}\n</code></pre> <p>Multiple Providers:</p> <p>You can register multiple <code>OutboxContextProvider</code> beans. The library automatically merges all context maps. If keys collide, the last provider wins.</p>"},{"location":"features/#accessing-context-in-handlers","title":"Accessing Context in Handlers","text":"<p>Context is available via <code>metadata.context</code> in primary handlers and <code>failureContext.context</code> in fallback handlers:</p> KotlinJava <pre><code>@Component\nclass OrderHandler {\n    @OutboxHandler\n    fun handle(payload: OrderEvent, metadata: OutboxRecordMetadata) {\n        // Access context via metadata.context\n        val traceId = metadata.context[\"traceId\"]\n        val spanId = metadata.context[\"spanId\"]\n        val tenantId = metadata.context[\"tenantId\"]\n\n        // Restore tracing context for downstream calls\n        tracer.withSpan(traceId, spanId) {\n            logger.info(\"Processing order ${payload.orderId} [trace: $traceId]\")\n            orderService.process(payload)\n        }\n    }\n\n    @OutboxFallbackHandler\n    fun handleFailure(payload: OrderEvent, context: OutboxFailureContext) {\n        // Access context via failureContext.context\n        val traceId = context.context[\"traceId\"]\n\n        logger.error(\n            \"Order ${payload.orderId} failed permanently [trace: $traceId]\",\n            context.lastException\n        )\n\n        deadLetterQueue.publish(\n            payload = payload,\n            context = mapOf(\"traceId\" to traceId)\n        )\n    }\n}\n</code></pre> <pre><code>@Component\npublic class OrderHandler {\n    @OutboxHandler\n    public void handle(OrderEvent payload, OutboxRecordMetadata metadata) {\n        // Access context via metadata.context\n        String traceId = metadata.getContext().get(\"traceId\");\n        String spanId = metadata.getContext().get(\"spanId\");\n        String tenantId = metadata.getContext().get(\"tenantId\");\n\n        // Restore tracing context for downstream calls\n        tracer.withSpan(traceId, spanId, () -&gt; {\n            logger.info(\"Processing order {} [trace: {}]\", payload.getOrderId(), traceId);\n            orderService.process(payload);\n        });\n    }\n\n    @OutboxFallbackHandler\n    public void handleFailure(OrderEvent payload, OutboxFailureContext context) {\n        // Access context via failureContext.context\n        String traceId = context.getContext().get(\"traceId\");\n\n        logger.error(\n            \"Order {} failed permanently [trace: {}]\",\n            payload.getOrderId(),\n            traceId,\n            context.getLastException()\n        );\n\n        deadLetterQueue.publish(payload, Map.of(\"traceId\", traceId));\n    }\n}\n</code></pre>"},{"location":"features/#manual-context-override","title":"Manual Context Override","text":"<p>You can also pass custom context directly when scheduling records:</p> KotlinJava <pre><code>@Service\nclass OrderService(private val outbox: Outbox) {\n    @Transactional\n    fun createOrder(command: CreateOrderCommand) {\n        val order = Order.create(command)\n        orderRepository.save(order)\n\n        // Override or extend context\n        outbox.schedule(\n            payload = OrderCreatedEvent(order.id, order.customerId),\n            key = \"order-${order.id}\",\n            context = mapOf(\n                \"correlationId\" to command.correlationId,\n                \"userId\" to command.userId,\n                \"priority\" to \"high\"\n            )\n        )\n    }\n}\n</code></pre> <pre><code>@Service\npublic class OrderService {\n    private final Outbox outbox;\n\n    @Transactional\n    public void createOrder(CreateOrderCommand command) {\n        Order order = Order.create(command);\n        orderRepository.save(order);\n\n        // Override or extend context\n        outbox.schedule(\n            new OrderCreatedEvent(order.getId()),\n            \"order-\" + order.getId(),\n            Map.of(\n                \"correlationId\", command.getCorrelationId(),\n                \"userId\", command.getUserId(),\n                \"priority\", \"high\"\n            )\n        );\n    }\n}\n</code></pre> <p>Context Merging:</p> <p>When you provide manual context, it's merged with context from registered <code>OutboxContextProvider</code> beans. Manual context takes precedence for duplicate keys.</p>"},{"location":"features/#use-cases_1","title":"Use Cases","text":"<p>Common use cases for context propagation:</p> <ol> <li>Distributed Tracing: Preserve trace and span IDs across async boundaries</li> <li>Multi-Tenancy: Maintain tenant context for data isolation</li> <li>Correlation IDs: Track requests across service boundaries</li> <li>User Context: Preserve user identity for audit logging</li> <li>Feature Flags: Propagate feature flag states for consistent behavior</li> <li>Request Metadata: Pass request IDs, client info, API versions</li> </ol>"},{"location":"features/#payload-serialization","title":"Payload Serialization","text":"<p>Records are serialized before storage and deserialized during processing. The library provides flexible serialization through the <code>OutboxPayloadSerializer</code> interface.</p>"},{"location":"features/#jackson-module-default","title":"Jackson Module (Default)","text":"<p>The <code>namastack-outbox-jackson</code> module provides default JSON serialization using Jackson 3.x:</p> <pre><code>dependencies:\n  implementation(\"io.namastack:namastack-outbox-starter-jpa\")  # Includes Jackson by default\n</code></pre> <p>Supported Features: - JSON serialization/deserialization - Custom Jackson modules and mixins - Standard Jackson configuration via <code>spring.jackson.*</code> properties</p> <p>Example Jackson Configuration:</p> <pre><code>spring:\n  jackson:\n    default-property-inclusion: NON_NULL\n    serialization:\n      write-dates-as-timestamps: false\n      indent-output: true\n    deserialization:\n      fail-on-unknown-properties: false\n</code></pre>"},{"location":"features/#outboxpayloadserializer-interface","title":"OutboxPayloadSerializer Interface","text":"<p>Implement custom serializers for alternative formats (Protobuf, Avro, XML, etc.):</p> KotlinJava <pre><code>interface OutboxPayloadSerializer {\n    fun serialize(payload: Any): String\n    fun &lt;T&gt; deserialize(data: String, targetType: Class&lt;T&gt;): T\n}\n</code></pre> <pre><code>public interface OutboxPayloadSerializer {\n    String serialize(Object payload);\n    &lt;T&gt; T deserialize(String data, Class&lt;T&gt; targetType);\n}\n</code></pre>"},{"location":"features/#custom-serializer-implementation","title":"Custom Serializer Implementation","text":"Kotlin - Protocol Buffers ExampleJava - Protocol Buffers Example <pre><code>@Configuration\nclass OutboxSerializationConfig {\n    @Bean\n    fun protobufSerializer(): OutboxPayloadSerializer {\n        return object : OutboxPayloadSerializer {\n            override fun serialize(payload: Any): String {\n                // Implement Protobuf serialization\n                require(payload is Message) { \"Payload must be Protobuf Message\" }\n                return Base64.encoder.encodeToString(payload.toByteArray())\n            }\n\n            override fun &lt;T&gt; deserialize(data: String, targetType: Class&lt;T&gt;): T {\n                // Implement Protobuf deserialization\n                val bytes = Base64.decoder.decode(data)\n                val method = targetType.getMethod(\"parseFrom\", ByteArray::class.java)\n                @Suppress(\"UNCHECKED_CAST\")\n                return method.invoke(null, bytes) as T\n            }\n        }\n    }\n}\n</code></pre> <pre><code>@Configuration\npublic class OutboxSerializationConfig {\n    @Bean\n    public OutboxPayloadSerializer protobufSerializer() {\n        return new OutboxPayloadSerializer() {\n            @Override\n            public String serialize(Object payload) {\n                if (!(payload instanceof Message)) {\n                    throw new IllegalArgumentException(\"Payload must be Protobuf Message\");\n                }\n                byte[] bytes = ((Message) payload).toByteArray();\n                return Base64.getEncoder().encodeToString(bytes);\n            }\n\n            @Override\n            public &lt;T&gt; T deserialize(String data, Class&lt;T&gt; targetType) {\n                try {\n                    byte[] bytes = Base64.getDecoder().decode(data);\n                    java.lang.reflect.Method method = targetType.getMethod(\"parseFrom\", byte[].class);\n                    return (T) method.invoke(null, bytes);\n                } catch (Exception e) {\n                    throw new RuntimeException(e);\n                }\n            }\n        };\n    }\n}\n</code></pre> <p>Important: When you provide a custom serializer as a Spring bean, it automatically replaces the default Jackson serializer.</p>"},{"location":"features/#retry-mechanisms","title":"Retry Mechanisms","text":"<p>The library provides sophisticated retry strategies to handle transient failures gracefully. You can configure a default retry policy for all handlers and optionally override it per handler.</p>"},{"location":"features/#default-retry-policy","title":"Default Retry Policy","text":"<p>The default retry policy applies to all handlers unless overridden. Configure it via <code>application.yml</code> or by providing a custom <code>OutboxRetryPolicy</code> bean.</p>"},{"location":"features/#built-in-retry-policies","title":"Built-in Retry Policies","text":""},{"location":"features/#fixed-delay","title":"Fixed Delay","text":"<p>Retry with a constant delay between attempts:</p> <pre><code>namastack:\n  outbox:\n    retry:\n      policy: \"fixed\"\n      max-retries: 5\n      fixed:\n        delay: 5000  # 5 seconds between retries\n</code></pre> <p>Use Case: Simple scenarios with consistent retry intervals</p> <p>Example Retry Schedule: 0s \u2192 5s \u2192 5s \u2192 5s \u2192 5s \u2192 5s \u2192 Failed</p>"},{"location":"features/#linear-backoff","title":"Linear Backoff","text":"<p>Retry with linearly increasing delays:</p> <pre><code>namastack:\n  outbox:\n    retry:\n      policy: \"linear\"\n      max-retries: 5\n      linear:\n        initial-delay: 2000    # Start with 2 seconds\n        increment: 2000        # Add 2 seconds each retry\n        max-delay: 60000       # Cap at 1 minute\n</code></pre> <p>Use Case: Gradually increasing delays for services that need time to recover</p> <p>Example Retry Schedule: 0s \u2192 2s \u2192 4s \u2192 6s \u2192 8s \u2192 10s \u2192 Failed</p>"},{"location":"features/#exponential-backoff","title":"Exponential Backoff","text":"<p>Retry with exponentially increasing delays:</p> <pre><code>namastack:\n  outbox:\n    retry:\n      policy: \"exponential\"\n      max-retries: 3\n      exponential:\n        initial-delay: 1000    # Start with 1 second\n        max-delay: 60000       # Cap at 1 minute\n        multiplier: 2.0        # Double each time\n</code></pre> <p>Use Case: Handles transient failures gracefully without overwhelming downstream services</p> <p>Retry Schedule: 0s \u2192 1s \u2192 2s \u2192 4s \u2192 8s \u2192 16s \u2192 32s (capped at 60s)</p>"},{"location":"features/#jittered-retry","title":"Jittered Retry","text":"<p>Add random jitter to prevent thundering herd problems. Jitter can be applied to any base policy (fixed, linear, or exponential):</p> <pre><code>namastack:\n  outbox:\n    retry:\n      policy: \"exponential\"  # Can also be \"fixed\" or \"linear\"\n      max-retries: 7\n      exponential:\n        initial-delay: 2000\n        max-delay: 60000\n        multiplier: 2.0\n      jitter: 1000  # Add [-1000ms, 1000ms] random delay\n</code></pre> <p>Benefits: Prevents coordinated retry storms when multiple instances retry simultaneously</p>"},{"location":"features/#exception-filtering","title":"Exception Filtering","text":"<p>Exception-Based Retry Control (Since 1.0.0)</p> <p>Control which exceptions trigger retries using include/exclude patterns.</p> <p>Configure which exceptions should trigger retries:</p> <pre><code>namastack:\n  outbox:\n    retry:\n      policy: exponential\n      max-retries: 3\n      exponential:\n        initial-delay: 1000\n        max-delay: 60000\n        multiplier: 2.0\n      # Only retry these exceptions\n    include-exceptions:\n      - java.net.SocketTimeoutException\n      - org.springframework.web.client.ResourceAccessException\n      - java.io.IOException\n    # Never retry these exceptions\n    exclude-exceptions:\n      - java.lang.IllegalArgumentException\n      - javax.validation.ValidationException\n      - com.example.BusinessException\n</code></pre> <p>Rules:</p> <ul> <li>If <code>include-exceptions</code> is set, only listed exceptions are retryable</li> <li>If <code>exclude-exceptions</code> is set, listed exceptions are never retried</li> <li>If both are set, <code>exclude-exceptions</code> takes precedence</li> <li>If neither is set, all exceptions are retryable (default behavior)</li> </ul> <p>Use Cases:</p> <ul> <li>include-exceptions: Whitelist transient errors (network, timeout, rate limiting)</li> <li>exclude-exceptions: Blacklist permanent errors (validation, business rules, auth failures)</li> </ul>"},{"location":"features/#custom-default-retry-policy","title":"Custom Default Retry Policy","text":"<p>Implement the <code>OutboxRetryPolicy</code> interface and register it as a bean named <code>outboxRetryPolicy</code>:</p> KotlinJava <pre><code>@Configuration\nclass OutboxConfig {\n    @Bean(\"outboxRetryPolicy\")\n    fun customRetryPolicy(): OutboxRetryPolicy {\n        return object : OutboxRetryPolicy {\n            override fun shouldRetry(exception: Throwable): Boolean {\n                // Don't retry validation errors\n                if (exception is IllegalArgumentException) return false\n\n                // Don't retry permanent failures\n                if (exception is PaymentDeclinedException) return false\n\n                // Retry transient failures\n                return exception is TimeoutException || \n                       exception is IOException ||\n                       exception.cause is TimeoutException\n            }\n\n            override fun nextDelay(failureCount: Int): Duration {\n                // Exponential backoff: 1s \u2192 2s \u2192 4s \u2192 8s (capped at 60s)\n                val delayMillis = 1000L * (1L shl failureCount)\n                return Duration.ofMillis(minOf(delayMillis, 60000L))\n            }\n\n            override fun maxRetries(): Int = 5\n        }\n    }\n}\n</code></pre> <pre><code>@Configuration\npublic class OutboxConfig {\n    @Bean(\"outboxRetryPolicy\")\n    public OutboxRetryPolicy customRetryPolicy() {\n        return new OutboxRetryPolicy() {\n            @Override\n            public boolean shouldRetry(Throwable exception) {\n                // Don't retry validation errors\n                if (exception instanceof IllegalArgumentException) return false;\n\n                // Don't retry permanent failures\n                if (exception instanceof PaymentDeclinedException) return false;\n\n                // Retry transient failures\n                return exception instanceof TimeoutException || \n                       exception instanceof IOException ||\n                       (exception.getCause() instanceof TimeoutException);\n            }\n\n            @Override\n            public Duration nextDelay(int failureCount) {\n                // Exponential backoff: 1s \u2192 2s \u2192 4s \u2192 8s (capped at 60s)\n                long delayMillis = 1000L * (1L &lt;&lt; failureCount);\n                return Duration.ofMillis(Math.min(delayMillis, 60000L));\n            }\n\n            @Override\n            public int maxRetries() {\n                return 5;\n            }\n        };\n    }\n}\n</code></pre> <p>Key Methods:</p> <ul> <li><code>shouldRetry(exception: Throwable): Boolean</code> - Decide if this error should be retried</li> <li><code>nextDelay(failureCount: Int): Duration</code> - Calculate delay before next retry</li> <li><code>maxRetries(): Int</code> - Maximum number of retry attempts</li> </ul> <p>Important: The bean must be named <code>outboxRetryPolicy</code> to override the default policy configured in <code>application.yml</code>.</p>"},{"location":"features/#handler-specific-retry-policies","title":"Handler-Specific Retry Policies","text":"<p>Per-Handler Retry Configuration (Since 1.0.0)</p> <p>Override the default retry policy for specific handlers using <code>@OutboxRetryable</code> annotation or by implementing the <code>OutboxRetryAware</code> interface.</p> <p>You can configure retry behavior per handler, allowing different handlers to have different retry strategies.</p>"},{"location":"features/#interface-based-approach","title":"Interface-Based Approach","text":"<p>Implement the <code>OutboxRetryAware</code> interface to specify a retry policy programmatically:</p> KotlinJava <pre><code>@Component\nclass PaymentHandler(\n    private val aggressiveRetryPolicy: AggressiveRetryPolicy\n) : OutboxTypedHandler&lt;PaymentEvent&gt;, OutboxRetryAware {\n\n    override fun handle(payload: PaymentEvent, metadata: OutboxRecordMetadata) {\n        paymentGateway.process(payload)\n    }\n\n    override fun getRetryPolicy(): OutboxRetryPolicy = aggressiveRetryPolicy\n}\n\n@Component\nclass NotificationHandler(\n    private val conservativeRetryPolicy: ConservativeRetryPolicy\n) : OutboxTypedHandler&lt;NotificationEvent&gt;, OutboxRetryAware {\n\n    override fun handle(payload: NotificationEvent, metadata: OutboxRecordMetadata) {\n        emailService.send(payload)\n    }\n\n    override fun getRetryPolicy(): OutboxRetryPolicy = conservativeRetryPolicy\n}\n\n@Component\nclass AggressiveRetryPolicy : OutboxRetryPolicy {\n    override fun shouldRetry(exception: Throwable) = true\n    override fun nextDelay(failureCount: Int) = Duration.ofMillis(500)\n    override fun maxRetries() = 10\n}\n\n@Component\nclass ConservativeRetryPolicy : OutboxRetryPolicy {\n    override fun shouldRetry(exception: Throwable) = \n        exception !is IllegalArgumentException\n    override fun nextDelay(failureCount: Int) = Duration.ofSeconds(10)\n    override fun maxRetries() = 2\n}\n</code></pre> <pre><code>@Component\npublic class PaymentHandler implements OutboxTypedHandler&lt;PaymentEvent&gt;, OutboxRetryAware {\n    private final AggressiveRetryPolicy aggressiveRetryPolicy;\n\n    public PaymentHandler(AggressiveRetryPolicy aggressiveRetryPolicy) {\n        this.aggressiveRetryPolicy = aggressiveRetryPolicy;\n    }\n\n    @Override\n    public void handle(PaymentEvent payload, OutboxRecordMetadata metadata) {\n        paymentGateway.process(payload);\n    }\n\n    @Override\n    public OutboxRetryPolicy getRetryPolicy() {\n        return aggressiveRetryPolicy;\n    }\n}\n\n@Component\npublic class NotificationHandler implements OutboxTypedHandler&lt;NotificationEvent&gt;, OutboxRetryAware {\n    private final ConservativeRetryPolicy conservativeRetryPolicy;\n\n    public NotificationHandler(ConservativeRetryPolicy conservativeRetryPolicy) {\n        this.conservativeRetryPolicy = conservativeRetryPolicy;\n    }\n\n    @Override\n    public void handle(NotificationEvent payload, OutboxRecordMetadata metadata) {\n        emailService.send(payload);\n    }\n\n    @Override\n    public OutboxRetryPolicy getRetryPolicy() {\n        return conservativeRetryPolicy;\n    }\n}\n\n@Component\npublic class AggressiveRetryPolicy implements OutboxRetryPolicy {\n    @Override\n    public boolean shouldRetry(Throwable exception) {\n        return true;\n    }\n\n    @Override\n    public Duration nextDelay(int failureCount) {\n        return Duration.ofMillis(500);\n    }\n\n    @Override\n    public int maxRetries() {\n        return 10;\n    }\n}\n\n@Component\npublic class ConservativeRetryPolicy implements OutboxRetryPolicy {\n    @Override\n    public boolean shouldRetry(Throwable exception) {\n        return !(exception instanceof IllegalArgumentException);\n    }\n\n    @Override\n    public Duration nextDelay(int failureCount) {\n        return Duration.ofSeconds(10);\n    }\n\n    @Override\n    public int maxRetries() {\n        return 2;\n    }\n}\n</code></pre>"},{"location":"features/#annotation-based-approach","title":"Annotation-Based Approach","text":"<p>Use the <code>@OutboxRetryable</code> annotation for method-level retry policy configuration:</p> KotlinJava <pre><code>@Component\nclass PaymentHandler {\n    // Critical handler - aggressive retries\n    @OutboxHandler\n    @OutboxRetryable(AggressiveRetryPolicy::class)\n    fun handlePayment(payload: PaymentEvent) {\n        paymentGateway.process(payload)\n    }\n\n    // Less critical handler - conservative retries\n    @OutboxHandler\n    @OutboxRetryable(ConservativeRetryPolicy::class)\n    fun handleNotification(payload: NotificationEvent) {\n        emailService.send(payload)\n    }\n\n    // Uses default retry policy\n    @OutboxHandler\n    fun handleAudit(payload: AuditEvent) {\n        auditService.log(payload)\n    }\n}\n\n@Component\nclass AggressiveRetryPolicy : OutboxRetryPolicy {\n    override fun shouldRetry(exception: Throwable) = true\n    override fun nextDelay(failureCount: Int) = Duration.ofMillis(500)\n    override fun maxRetries() = 10\n}\n\n@Component\nclass ConservativeRetryPolicy : OutboxRetryPolicy {\n    override fun shouldRetry(exception: Throwable) = \n        exception !is IllegalArgumentException\n    override fun nextDelay(failureCount: Int) = Duration.ofSeconds(10)\n    override fun maxRetries() = 2\n}\n</code></pre> <pre><code>@Component\npublic class PaymentHandler {\n    // Critical handler - aggressive retries\n    @OutboxHandler\n    @OutboxRetryable(AggressiveRetryPolicy.class)\n    public void handlePayment(PaymentEvent payload) {\n        paymentGateway.process(payload);\n    }\n\n    // Less critical handler - conservative retries\n    @OutboxHandler\n    @OutboxRetryable(ConservativeRetryPolicy.class)\n    public void handleNotification(NotificationEvent payload) {\n        emailService.send(payload);\n    }\n\n    // Uses default retry policy\n    @OutboxHandler\n    public void handleAudit(AuditEvent payload) {\n        auditService.log(payload);\n    }\n}\n\n@Component\npublic class AggressiveRetryPolicy implements OutboxRetryPolicy {\n    @Override\n    public boolean shouldRetry(Throwable exception) {\n        return true;\n    }\n\n    @Override\n    public Duration nextDelay(int failureCount) {\n        return Duration.ofMillis(500);\n    }\n\n    @Override\n    public int maxRetries() {\n        return 10;\n    }\n}\n\n@Component\npublic class ConservativeRetryPolicy implements OutboxRetryPolicy {\n    @Override\n    public boolean shouldRetry(Throwable exception) {\n        return !(exception instanceof IllegalArgumentException);\n    }\n\n    @Override\n    public Duration nextDelay(int failureCount) {\n        return Duration.ofSeconds(10);\n    }\n\n    @Override\n    public int maxRetries() {\n        return 2;\n    }\n}\n</code></pre> <p>Policy Resolution Order:</p> <ol> <li>Handler-specific policy via interface (<code>OutboxRetryAware.getRetryPolicy()</code>) - highest priority</li> <li>Handler-specific policy via annotation (<code>@OutboxRetryable</code>)</li> <li>Global custom policy (bean named <code>outboxRetryPolicy</code>)</li> <li>Default policy (from <code>application.yml</code>)</li> </ol> <p>Interface vs Annotation</p> <ul> <li>Interface (<code>OutboxRetryAware</code>): Best when handler class is dedicated to single payload type, and you want type safety</li> <li>Annotation (<code>@OutboxRetryable</code>): Best for method-level handlers or multiple handlers in one class</li> </ul>"},{"location":"features/#outboxretrypolicybuilder-api","title":"OutboxRetryPolicy.Builder API","text":"<p>Use the fluent builder to compose robust retry policies without implementing the interface yourself.</p> KotlinJava <pre><code>@Configuration\nclass OutboxConfig {\n    @Bean\n    fun customRetryPolicy(): OutboxRetryPolicy {\n        return OutboxRetryPolicy.builder()\n            .maxRetries(5)\n            .exponentialBackoff(\n                initialDelay = Duration.ofSeconds(10),\n                multiplier = 2.0,\n                maxDelay = Duration.ofMinutes(5)\n            )\n            .jitter(Duration.ofSeconds(2))\n            .retryOn(TimeoutException::class.java, IOException::class.java)\n            .noRetryOn(IllegalArgumentException::class.java)\n            .build()\n    }\n}\n</code></pre> <pre><code>@Configuration\npublic class OutboxConfig {\n    @Bean\n    public OutboxRetryPolicy customRetryPolicy() {\n        return OutboxRetryPolicy.builder()\n            .maxRetries(5)\n            .exponentialBackoff(\n                Duration.ofSeconds(10),\n                2.0,\n                Duration.ofMinutes(5)\n            )\n            .jitter(Duration.ofSeconds(2))\n            .retryOn(TimeoutException.class, IOException.class)\n            .noRetryOn(IllegalArgumentException.class)\n            .build();\n    }\n}\n</code></pre> <p>Builder at a glance:</p> <ul> <li>Defaults: maxRetries = 3, fixedBackOff = 5s, jitter = 0, retry on all exceptions</li> <li>Immutability: each method returns a new Builder; the original instance isn\u2019t mutated</li> <li>Validation: durations must be &gt; 0 (except jitter, which can be 0), multiplier &gt; 1.0</li> </ul>"},{"location":"features/#using-the-autoconfigured-builder","title":"Using the autoconfigured Builder:","text":"<p>A bean named <code>outboxRetryPolicyBuilder</code> is auto-configured from your <code>namastack.outbox.retry.*</code> application properties. Inject it to retain property-driven defaults and add programmatic customizations.</p> KotlinJava <pre><code>@Configuration\nclass OutboxConfig {\n    // Inject the autoconfigured builder from application.yml\n    @Bean\n    fun customRetryPolicy(\n        builder: OutboxRetryPolicy.Builder\n    ): OutboxRetryPolicy {\n        // Start from property-based defaults, then refine\n        return builder\n            .retryOn(TimeoutException::class.java, IOException::class.java)\n            .noRetryOn(IllegalArgumentException::class.java)\n            .build()\n    }\n}\n</code></pre> <pre><code>@Configuration\npublic class OutboxConfig {\n    // Inject the autoconfigured builder from application.yml\n    @Bean\n    public OutboxRetryPolicy customRetryPolicy(\n        OutboxRetryPolicy.Builder builder\n    ) {\n        // Start from property-based defaults, then refine\n        return builder\n            .retryOn(TimeoutException.class, IOException.class)\n            .noRetryOn(IllegalArgumentException.class)\n            .build();\n    }\n}\n</code></pre>"},{"location":"features/#builder-configuration-options","title":"Builder configuration options","text":"<p>Backoff strategies:</p> <ul> <li> <p>Fixed: same delay for all retries <code>fixedBackOff(Duration.ofSeconds(30))</code></p> </li> <li> <p>Linear: incrementally increasing delay <code>linearBackoff(initialDelay = Duration.ofSeconds(5), increment = Duration.ofSeconds(5), maxDelay = Duration.ofMinutes(2))</code></p> </li> <li> <p>Exponential: exponentially increasing delay <code>exponentialBackoff(initialDelay = Duration.ofSeconds(10), multiplier = 2.0, maxDelay = Duration.ofMinutes(5))</code></p> </li> <li> <p>Custom: provide your own strategy <code>backOff(myCustomBackOffStrategy)</code></p> </li> </ul> <p>Jitter:</p> <p>Jitter randomizes the computed delay within [base - jitter, base + jitter] to avoid thundering herds; delays never go below zero.</p> <pre><code>OutboxRetryPolicy.builder()\n    .fixedBackOff(Duration.ofSeconds(30))\n    .jitter(Duration.ofSeconds(5))  // Actual delay: ~25\u201335 seconds\n</code></pre> <p>Exception rules and priority:</p> <ul> <li>noRetryOn(): these exceptions are never retried (highest priority)</li> <li>retryOn(): if specified, only these exceptions (or subclasses) are retried</li> <li>retryIf(): predicate for advanced logic</li> <li>Default: if neither retryOn() nor retryIf() is configured, all exceptions are retried; if any rule is configured but none match, do not retry</li> </ul> KotlinJava <pre><code>// Retry only on specific exceptions\nOutboxRetryPolicy.builder()\n    .retryOn(TimeoutException::class.java, IOException::class.java)\n    .build()\n\n// Retry all except specific exceptions\nOutboxRetryPolicy.builder()\n    .noRetryOn(IllegalArgumentException::class.java, PaymentDeclinedException::class.java)\n    .build()\n\n// Custom predicate for complex logic\nOutboxRetryPolicy.builder()\n    .retryIf { exception -&gt;\n        exception is RetryableException ||\n        (exception.cause is TimeoutException)\n    }\n    .build()\n\n// Combine multiple rules (noRetryOn takes precedence)\nOutboxRetryPolicy.builder()\n    .retryOn(IOException::class.java)\n    .noRetryOn(FileNotFoundException::class.java)\n    .retryIf { exception -&gt; exception.message?.contains(\"transient\") == true }\n    .build()\n</code></pre> <pre><code>// Retry only on specific exceptions\nOutboxRetryPolicy.builder()\n    .retryOn(TimeoutException.class, IOException.class)\n    .build();\n\n// Retry all except specific exceptions\nOutboxRetryPolicy.builder()\n    .noRetryOn(IllegalArgumentException.class, PaymentDeclinedException.class)\n    .build();\n\n// Custom predicate for complex logic\nOutboxRetryPolicy.builder()\n    .retryIf(exception -&gt;\n        exception instanceof RetryableException ||\n        (exception.getCause() instanceof TimeoutException)\n    )\n    .build();\n\n// Combine multiple rules (noRetryOn takes precedence)\nOutboxRetryPolicy.builder()\n    .retryOn(IOException.class)\n    .noRetryOn(FileNotFoundException.class)\n    .retryIf(exception -&gt;\n        exception.getMessage() != null &amp;&amp;\n        exception.getMessage().contains(\"transient\")\n    )\n    .build();\n</code></pre> <p>Complete examples:</p> KotlinJava <pre><code>// Simple policy with exponential backoff\nval simplePolicy = OutboxRetryPolicy.builder()\n    .maxRetries(5)\n    .exponentialBackoff(\n        initialDelay = Duration.ofSeconds(10),\n        multiplier = 2.0,\n        maxDelay = Duration.ofMinutes(5)\n    )\n    .build()\n\n// Advanced policy with all features\nval advancedPolicy = OutboxRetryPolicy.builder()\n    .maxRetries(10)\n    .linearBackoff(\n        initialDelay = Duration.ofSeconds(5),\n        increment = Duration.ofSeconds(5),\n        maxDelay = Duration.ofMinutes(2)\n    )\n    .jitter(Duration.ofSeconds(2))\n    .retryOn(TimeoutException::class.java, IOException::class.java)\n    .noRetryOn(IllegalArgumentException::class.java)\n    .retryIf { exception -&gt;\n        exception.message?.contains(\"retry\", ignoreCase = true) == true\n    }\n    .build()\n</code></pre> <pre><code>// Simple policy with exponential backoff\nOutboxRetryPolicy simplePolicy = OutboxRetryPolicy.builder()\n    .maxRetries(5)\n    .exponentialBackoff(\n        Duration.ofSeconds(10),\n        2.0,\n        Duration.ofMinutes(5)\n    )\n    .build();\n\n// Advanced policy with all features\nOutboxRetryPolicy advancedPolicy = OutboxRetryPolicy.builder()\n    .maxRetries(10)\n    .linearBackoff(\n        Duration.ofSeconds(5),\n        Duration.ofSeconds(5),\n        Duration.ofMinutes(2)\n    )\n    .jitter(Duration.ofSeconds(2))\n    .retryOn(TimeoutException.class, IOException.class)\n    .noRetryOn(IllegalArgumentException.class)\n    .retryIf(exception -&gt;\n        exception.getMessage() != null &amp;&amp;\n        exception.getMessage().toLowerCase().contains(\"retry\")\n    )\n    .build();\n</code></pre>"},{"location":"features/#persistence-modules","title":"Persistence Modules","text":"<p>Namastack Outbox provides two persistence modules to choose from based on your needs.</p>"},{"location":"features/#jpa-module","title":"JPA Module","text":"<p>The JPA module uses Hibernate/JPA for database operations. Best for projects already using Spring Data JPA.</p> GradleMaven <pre><code>dependencies {\n    implementation(\"io.namastack:namastack-outbox-starter-jpa:1.0.0\")\n}\n</code></pre> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.namastack&lt;/groupId&gt;\n    &lt;artifactId&gt;namastack-outbox-starter-jpa&lt;/artifactId&gt;\n    &lt;version&gt;1.0.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Schema Management</p> <p>The JPA module does not support automatic schema creation. You must manage schemas using:</p> <ul> <li>Flyway/Liquibase (recommended for production) - Use the SQL schema files</li> <li>Hibernate DDL Auto (<code>ddl-auto: create</code>) for development</li> </ul>"},{"location":"features/#jdbc-module","title":"JDBC Module","text":"<p>The JDBC module uses Spring's <code>JdbcClient</code> for database operations. Best for projects that don't use JPA or want lower overhead.</p> GradleMaven <pre><code>dependencies {\n    implementation(\"io.namastack:namastack-outbox-starter-jdbc:1.0.0\")\n}\n</code></pre> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.namastack&lt;/groupId&gt;\n    &lt;artifactId&gt;namastack-outbox-starter-jdbc&lt;/artifactId&gt;\n    &lt;version&gt;1.0.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Benefits:</p> <ul> <li>No Hibernate/JPA dependency required</li> <li>Built-in automatic schema initialization</li> <li>Support for custom table prefixes and schema names</li> <li>Lower memory footprint</li> </ul>"},{"location":"features/#automatic-schema-creation-jdbc-only","title":"Automatic Schema Creation (JDBC Only)","text":"<p>The JDBC module automatically creates outbox tables on startup by default:</p> <pre><code>namastack:\n  outbox:\n    jdbc:\n      schema-initialization:\n        enabled: true  # Auto-create tables on startup (default: true)\n</code></pre> <p>Database Detection</p> <p>The JDBC module automatically detects your database type and uses the appropriate schema. Supported databases: PostgreSQL, MySQL, MariaDB, H2, SQL Server.</p>"},{"location":"features/#custom-table-prefix-and-schema-name","title":"Custom Table Prefix and Schema Name","text":"<p>The JDBC module supports custom table naming for multi-tenant deployments or naming conventions:</p> <pre><code>namastack:\n  outbox:\n    jdbc:\n      table-prefix: \"myapp_\"           # Results in: myapp_outbox_record, myapp_outbox_instance, etc.\n      schema-name: \"outbox_schema\"     # Results in: outbox_schema.myapp_outbox_record\n</code></pre> <p>Examples:</p> Configuration Resulting Table Name Default <code>outbox_record</code> <code>table-prefix: \"app1_\"</code> <code>app1_outbox_record</code> <code>schema-name: \"myschema\"</code> <code>myschema.outbox_record</code> Both <code>myschema.app1_outbox_record</code> <p>Schema Initialization Limitation</p> <p>When using custom table prefix or schema name, you must disable schema initialization (which is enabled by default). Schema initialization cannot be used with custom naming:</p> <pre><code>namastack:\n  outbox:\n    jdbc:\n      table-prefix: \"myapp_\"\n      schema-name: \"custom_schema\"\n      schema-initialization:\n        enabled: false  # Must be false when using custom naming\n</code></pre> <p>Manual Schema Creation:</p> <p>Use the SQL schema files as templates and adjust table names: \ud83d\udc49 Schema Files on GitHub</p>"},{"location":"features/#virtual-threads-support","title":"Virtual Threads Support","text":"<p>When virtual threads are enabled in Spring Boot, Namastack Outbox automatically uses virtual threads for outbox processing, providing better scalability for I/O-bound workloads.</p>"},{"location":"features/#enabling-virtual-threads","title":"Enabling Virtual Threads","text":"<p>Enable virtual threads in your Spring Boot application:</p> <pre><code>spring:\n  threads:\n    virtual:\n      enabled: true\n</code></pre> <p>Benefits:</p> <ul> <li>Higher Throughput: Handle more concurrent outbox records with fewer resources</li> <li>Lower Memory: Virtual threads have minimal memory overhead</li> <li>Better I/O Handling: Ideal for handlers that make external API calls</li> <li>Automatic: No code changes required - the library detects and uses virtual threads automatically</li> </ul>"},{"location":"features/#configuration_1","title":"Configuration","text":"<p>When virtual threads are enabled, use the concurrency limit instead of pool sizes:</p> <pre><code>namastack:\n  outbox:\n    processing:\n      executor-concurrency-limit: -1           # -1 for unlimited, or set a specific limit\n</code></pre> <p>Platform Threads</p> <p>When virtual threads are disabled (default), the library uses traditional thread pools: <pre><code>namastack:\n  outbox:\n    processing:\n      executor-core-pool-size: 4\n      executor-max-pool-size: 8\n</code></pre></p>"},{"location":"features/#database-support","title":"Database Support","text":""},{"location":"features/#supported-databases","title":"Supported Databases","text":"<p>Any JPA/JDBC-compatible database is supported. Automatic schema creation (JDBC module only) is available for:</p> <ul> <li>\u2705 H2 (development)</li> <li>\u2705 MySQL / MariaDB</li> <li>\u2705 PostgreSQL</li> <li>\u2705 SQL Server</li> </ul>"},{"location":"features/#schema-management","title":"Schema Management","text":""},{"location":"features/#jdbc-module_1","title":"JDBC Module","text":"<p>The JDBC module automatically creates its schema on startup by default. You can disable it:</p> <pre><code>namastack:\n  outbox:\n    jdbc:\n      schema-initialization:\n        enabled: false\n</code></pre>"},{"location":"features/#jpa-module_1","title":"JPA Module","text":"<p>The JPA module does not support automatic schema creation. Use one of these approaches:</p> <p>Option 1: Hibernate DDL Auto (Development) <pre><code>spring:\n  jpa:\n    hibernate:\n      ddl-auto: create  # or create-drop, update\n</code></pre></p> <p>Option 2: Flyway/Liquibase (Production)</p> <p>Create tables manually using migration scripts. Database-specific schemas are available: \ud83d\udc49 Schema Files on GitHub</p> <p>Then configure Hibernate to validate the schema: <pre><code>spring:\n  jpa:\n    hibernate:\n      ddl-auto: validate\n</code></pre></p>"},{"location":"features/#monitoring-observability","title":"Monitoring &amp; Observability","text":""},{"location":"features/#metrics-module","title":"Metrics Module","text":"<p>The <code>namastack-outbox-metrics</code> module provides automatic integration with Spring Boot Actuator and Micrometer:</p> GradleMaven <pre><code>dependencies {\n    implementation(\"io.namastack:namastack-outbox-starter-jpa\")\n    implementation(\"io.namastack:namastack-outbox-metrics\")\n\n    // For Prometheus endpoint (optional)\n    implementation(\"io.micrometer:micrometer-registry-prometheus\")\n}\n</code></pre> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.namastack&lt;/groupId&gt;\n    &lt;artifactId&gt;namastack-outbox-metrics&lt;/artifactId&gt;\n    &lt;version&gt;${namastack-outbox.version}&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"features/#built-in-metrics","title":"Built-in Metrics","text":"Metric Description Tags <code>outbox.records.count</code> Number of outbox records <code>status=new\\|failed\\|completed</code> <code>outbox.partitions.assigned.count</code> Partitions assigned to this instance - <code>outbox.partitions.pending.records.total</code> Total pending records across partitions - <code>outbox.partitions.pending.records.max</code> Maximum pending records in any partition - <code>outbox.cluster.instances.total</code> Total active instances in cluster - <p>Endpoints:</p> <ul> <li><code>/actuator/metrics/outbox.records.count</code></li> <li><code>/actuator/metrics/outbox.partitions.assigned.count</code></li> <li><code>/actuator/prometheus</code> (if Prometheus enabled)</li> </ul>"},{"location":"features/#programmatic-monitoring","title":"Programmatic Monitoring","text":"KotlinJava <pre><code>@Service\nclass OutboxMonitoringService(\n    private val outboxRepository: OutboxRecordRepository,\n    private val partitionMetricsProvider: OutboxPartitionMetricsProvider\n) {\n    fun getPendingRecordCount(): Long =\n        outboxRepository.countByStatus(OutboxRecordStatus.NEW)\n\n    fun getFailedRecordCount(): Long =\n        outboxRepository.countByStatus(OutboxRecordStatus.FAILED)\n\n    fun getPartitionStats(): PartitionProcessingStats =\n        partitionMetricsProvider.getProcessingStats()\n\n    fun getClusterStats(): PartitionStats =\n        partitionMetricsProvider.getPartitionStats()\n}\n</code></pre> <pre><code>@Service\npublic class OutboxMonitoringService {\n    private final OutboxRecordRepository outboxRepository;\n    private final OutboxPartitionMetricsProvider partitionMetricsProvider;\n\n    public OutboxMonitoringService(OutboxRecordRepository outboxRepository,\n                                   OutboxPartitionMetricsProvider partitionMetricsProvider) {\n        this.outboxRepository = outboxRepository;\n        this.partitionMetricsProvider = partitionMetricsProvider;\n    }\n\n    public long getPendingRecordCount() {\n        return outboxRepository.countByStatus(OutboxRecordStatus.NEW);\n    }\n\n    public long getFailedRecordCount() {\n        return outboxRepository.countByStatus(OutboxRecordStatus.FAILED);\n    }\n\n    public PartitionProcessingStats getPartitionStats() {\n        return partitionMetricsProvider.getProcessingStats();\n    }\n\n    public PartitionStats getClusterStats() {\n        return partitionMetricsProvider.getPartitionStats();\n    }\n}\n</code></pre>"},{"location":"features/#configuration-reference","title":"Configuration Reference","text":"<p>Complete reference of all configuration options:</p> <pre><code>namastack:\n  outbox:\n    enabled: true                              # Enable outbox functionality (default: true)\n\n    # Polling Configuration\n    poll-interval: 2000                        # Milliseconds between polling cycles (default: 2000)\n    rebalance-interval: 10000                  # Milliseconds between rebalance checks (default: 10000)\n    batch-size: 10                             # Records per poll cycle (default: 10)\n\n    # Processing Configuration\n    processing:\n      stop-on-first-failure: true              # Stop processing on first failure (default: true)\n      publish-after-save: true                 # Publish events to listeners after saving (default: true)\n      delete-completed-records: false          # Delete records after completion (default: false)\n      executor-core-pool-size: 4               # Core threads for processing (default: 4, platform threads)\n      executor-max-pool-size: 8                # Maximum threads for processing (default: 8, platform threads)\n      executor-concurrency-limit: -1           # Concurrency limit for virtual threads (default: -1 unlimited)\n\n    # Event Multicaster Configuration\n    multicaster:\n      enabled: true                            # Enable @OutboxEvent interception (default: true)\n\n    # Instance Coordination Configuration\n    instance:\n      graceful-shutdown-timeout-seconds: 0     # Graceful shutdown propagation window (default: 0)\n      stale-instance-timeout-seconds: 30       # When an instance is considered stale and removed (default: 30)\n      heartbeat-interval-seconds: 5            # How often each instance sends a heartbeat (default: 5)\n      rebalance-interval: 10000                # How often partitions are recalculated (default: 10000)\n\n    jdbc:\n      table-prefix: \"\"                         # Prefix for table names (default: empty)\n      schema-name: null                        # Database schema name (default: null, uses default schema)\n      schema-initialization:\n        enabled: true                          # Auto-create tables on startup (default: true)\n\n    # Retry Configuration\n    retry:\n      policy: exponential                      # Retry policy: fixed|linear|exponential (default: exponential)\n      max-retries: 3                           # Maximum retry attempts (default: 3)\n\n      # Exception Filtering (Since 1.0.0)\n      include-exceptions:                      # Only retry these exceptions (optional)\n        - java.net.SocketTimeoutException\n        - org.springframework.web.client.ResourceAccessException\n      exclude-exceptions:                      # Never retry these exceptions (optional)\n        - java.lang.IllegalArgumentException\n        - javax.validation.ValidationException\n\n      # Fixed Delay Policy\n      fixed:\n        delay: 5000                            # Delay in milliseconds (default: 5000)\n\n      # Linear Backoff Policy\n      linear:\n        initial-delay: 2000                    # Initial delay in milliseconds (default: 2000)\n        increment: 2000                        # Increment per retry in milliseconds (default: 2000)\n        max-delay: 60000                       # Maximum delay cap in milliseconds (default: 60000)\n\n      # Exponential Backoff Policy\n      exponential:\n        initial-delay: 1000                    # Initial delay in milliseconds (default: 1000)\n        max-delay: 60000                       # Maximum delay cap in milliseconds (default: 60000)\n        multiplier: 2.0                        # Backoff multiplier (default: 2.0)\n\n      # Jitter Configuration (can be used with any policy)\n      jitter: 0                                # Max random jitter in milliseconds (default: 0)\n</code></pre>"},{"location":"features/#disabling-outbox","title":"Disabling Outbox","text":"<p>To completely disable outbox functionality:</p> <pre><code>namastack:\n  outbox:\n    enabled: false\n</code></pre> <p>This prevents all outbox beans from being created, useful for:</p> <ul> <li>Running tests without outbox processing</li> <li>Temporarily disabling outbox in specific environments</li> <li>Conditional feature flags</li> </ul>"},{"location":"features/#reliability-guarantees","title":"Reliability Guarantees","text":""},{"location":"features/#what-namastack-outbox-for-spring-boot-guarantees","title":"What Namastack Outbox for Spring Boot Guarantees","text":"<ul> <li> At-least-once delivery: Records will be processed at least once</li> <li> Ordering per key: Records with the same key are processed in order</li> <li> Failure recovery: System failures don't result in lost records</li> <li> Horizontal scalability: Multiple instances process different partitions</li> <li> Consistency: Database transactions ensure data integrity</li> <li> Automatic retry: Failed records are automatically retried</li> <li> Automatic rebalancing: Partitions redistribute on topology changes</li> <li> Linear scaling: Performance scales with instance count</li> </ul>"},{"location":"features/#what-namastack-outbox-for-spring-boot-does-not-guarantee","title":"What Namastack Outbox for Spring Boot Does NOT Guarantee","text":"<ul> <li> Exactly-once delivery: Records may be processed multiple times (handlers should be idempotent)</li> <li> Global ordering: No ordering guarantee across different keys</li> <li> Real-time processing: Records are processed asynchronously with configurable delays</li> </ul> <p>Next Steps</p> <p>Ready to get started? Check out the Quick Start Guide to integrate Namastack Outbox for Spring Boot into your application.</p>"},{"location":"legal-notice/","title":"Legal Notice / Impressum","text":"<p>Namastack Outbox for Spring Boot is Free and Open Source Software. The project is maintained by Roland Beisel, who is responsible for its ongoing development. Namastack Outbox for Spring Boot provides a robust and reliable solution for event-driven message handling and outbox pattern implementations in modern applications.</p> <p>The project is part of a broader open-source initiative and welcomes contributions, feedback, and voluntary donations to support its development and sustainability.</p> <p>Last updated: January 2026</p>"},{"location":"legal-notice/#information-according-to-5-tmg-and-18-abs-2-mstv","title":"Information according to \u00a7 5 TMG and \u00a7 18 Abs. 2 MStV","text":"<p>Roland Beisel Ober-Eschbacher Str. 42 61352 Bad Homburg info@rolandbeisel.de +49 176 68639673</p> <p>Namastack Outbox for Spring Boot is an open-source project maintained by namastack.io. It is non-commercial in nature and accepts voluntary donations to support its development.</p>"},{"location":"legal-notice/#hosting-provider","title":"Hosting Provider","text":"<p>Our website is hosted on:</p> <p>GitHub Pages GitHub Inc. 88 Colin P Kelly Jr St, San Francisco, CA 94107, USA</p> <p>Data may be transmitted to servers in the United States. GitHub is part of Microsoft Corporation, which participates in the EU\u2013U.S. Data Privacy Framework.</p>"},{"location":"legal-notice/#datenschutzerklarung-german-privacy-policy","title":"Datenschutzerkl\u00e4rung (German Privacy Policy)","text":"<p>Im Folgenden informieren wir Sie \u00fcber die Verarbeitung personenbezogener Daten auf dieser Website.</p>"},{"location":"legal-notice/#hosting-durch-github-pages","title":"Hosting durch GitHub Pages","text":"<p>Unsere Website wird bei GitHub Pages (GitHub Inc., 88 Colin P Kelly Jr St, San Francisco, CA 94107, USA) gehostet. Dabei kann es zu einer \u00dcbertragung personenbezogener Daten in die USA kommen. Microsoft, die Muttergesellschaft von GitHub, ist nach dem EU-US Data Privacy Framework zertifiziert.</p>"},{"location":"legal-notice/#google-analytics-4","title":"Google Analytics 4","text":"<p>Unsere Website verwendet Google Analytics, einen Webanalysedienst der Google Ireland Limited (\u201eGoogle\u201c), Gordon House, Barrow Street, Dublin 4, Irland. Google Analytics erm\u00f6glicht uns, das Nutzerverhalten auf unserer Website zu analysieren und damit unser Angebot zu verbessern.</p> <p>Google Analytics 4 nutzt Cookies oder vergleichbare Technologien, um Informationen \u00fcber Ihre Nutzung der Website zu erfassen und an Google zu \u00fcbertragen. Google anonymisiert IP-Adressen standardm\u00e4\u00dfig, sodass Ihre vollst\u00e4ndige IP-Adresse nicht gespeichert wird.</p> <p>Die Verarbeitung erfolgt ausschlie\u00dflich auf Grundlage Ihrer Einwilligung gem\u00e4\u00df Art. 6 Abs. 1 lit. a DSGVO. Sie k\u00f6nnen Ihre Einwilligung jederzeit \u00fcber das Cookie-Banner widerrufen.</p> <p>Es kann nicht ausgeschlossen werden, dass Daten in die USA \u00fcbertragen und dort verarbeitet werden. Google LLC ist nach dem EU-US Data Privacy Framework zertifiziert, wodurch ein angemessenes Datenschutzniveau gew\u00e4hrleistet ist.</p> <p>Wir haben mit Google einen Auftragsverarbeitungsvertrag gem\u00e4\u00df Art. 28 DSGVO abgeschlossen.</p> <p>Die von Google verarbeiteten Daten werden standardm\u00e4\u00dfig nach 2 Monaten gel\u00f6scht bzw. anonymisiert, sofern keine gesetzlichen Aufbewahrungspflichten bestehen.</p> <p>Sie k\u00f6nnen die Erfassung Ihrer Daten durch Google Analytics verhindern, indem Sie Ihre Cookie-Einstellungen \u00e4ndern und die Einwilligung f\u00fcr Statistik-Cookies widerrufen. Zus\u00e4tzlich k\u00f6nnen Sie das folgende Browser-Plugin installieren: https://tools.google.com/dlpage/gaoptout/</p>"},{"location":"legal-notice/#privacy-policy-english","title":"Privacy Policy (English)","text":"<p>Below we explain how personal data is processed on this website.</p>"},{"location":"legal-notice/#hosting-via-github-pages","title":"Hosting via GitHub Pages","text":"<p>Our website is hosted on GitHub Pages (GitHub Inc., 88 Colin P Kelly Jr St, San Francisco, CA 94107, USA). Data may be transferred to servers in the United States. GitHub is owned by Microsoft Corporation, which is certified under the EU\u2013U.S. Data Privacy Framework.</p>"},{"location":"legal-notice/#google-analytics-4_1","title":"Google Analytics 4","text":"<p>Our website uses Google Analytics, a web analytics service provided by Google Ireland Limited (\u201cGoogle\u201d), Gordon House, Barrow Street, Dublin 4, Ireland. Google Analytics enables us to analyze user behavior and improve our services accordingly.</p> <p>Google Analytics 4 uses cookies or similar technologies to collect information about your use of the website and transmit it to Google. IP addresses are anonymized by default in Google Analytics, so your full IP address is not stored.</p> <p>Processing is carried out exclusively on the basis of your consent pursuant to Art. 6 (1) (a) GDPR. You may withdraw your consent at any time via the cookie banner.</p> <p>It cannot be ruled out that data may be transferred to and processed in the United States. Google LLC is certified under the EU-U.S. Data Privacy Framework, ensuring an adequate level of data protection.</p> <p>We have concluded a data processing agreement with Google pursuant to Art. 28 GDPR.</p> <p>Data processed by Google is deleted or anonymized after 2 months by default, unless statutory retention obligations apply.</p> <p>You can prevent the collection of your data by Google Analytics by adjusting your cookie settings and withdrawing your consent for statistics cookies. Additionally, you can install the following browser plugin: https://tools.google.com/dlpage/gaoptout/</p>"},{"location":"legal-notice/#license-copyright","title":"License / Copyright","text":"<p>\u00a9 2026 namastack.io. Namastack Outbox for Spring Boot is licensed under the Apache License 2.0.</p>"},{"location":"legal-notice/#trademarks","title":"Trademarks","text":"<p>Spring\u00ae, Spring Boot\u00ae, and the Spring leaf logo are trademarks of Broadcom Inc. and/or its subsidiaries. Java\u2122 and OpenJDK\u2122 are trademarks of Oracle and/or its affiliates. PostgreSQL\u00ae, MySQL\u00ae, and other database names are trademarks of their respective owners. AWS\u2122 and Amazon Web Services\u2122 are trademarks of Amazon.com, Inc. or its affiliates. Apache\u00ae, Apache Kafka\u00ae, Apache Tomcat\u00ae, and Apache Cassandra\u2122 are trademarks of the Apache Software Foundation.</p> <p>All other trademarks are the property of their respective owners.</p> <p>This project is an independent open-source project and is not affiliated with, endorsed by, or sponsored by Broadcom Inc. or the Spring team.</p>"},{"location":"quickstart/","title":"Quickstart","text":"<p>Namastack Outbox for Spring Boot is a robust Spring Boot library for Java and Kotlin projects that implements the  Transactional Outbox Pattern for reliable record publishing in distributed systems. Ensures  records are never lost through atomic persistence and automatic retry logic with handler-based processing and partition-aware horizontal scaling.</p> <p>This guide will get you up and running in 5 minutes with minimal configuration.</p>"},{"location":"quickstart/#add-dependency","title":"Add Dependency","text":"GradleMaven <pre><code>dependencies {\n    implementation(\"io.namastack:namastack-outbox-starter-jdbc:1.0.0\")\n}\n</code></pre> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.namastack&lt;/groupId&gt;\n    &lt;artifactId&gt;namastack-outbox-starter-jdbc&lt;/artifactId&gt;\n    &lt;version&gt;1.0.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>JDBC vs JPA</p> <p>We recommend the JDBC starter for quick start as it supports automatic schema creation. For JPA/Hibernate projects, see JPA Setup below.</p>"},{"location":"quickstart/#enable-scheduling","title":"Enable Scheduling","text":"KotlinJava <pre><code>@SpringBootApplication\n@EnableScheduling  // Required for automatic outbox processing\nclass Application\n\nfun main(args: Array&lt;String&gt;) {\n    runApplication&lt;Application&gt;(*args)\n}\n</code></pre> <pre><code>@SpringBootApplication\n@EnableScheduling  // Required for automatic outbox processing\npublic class Application {\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n}\n</code></pre>"},{"location":"quickstart/#create-handlers","title":"Create Handlers","text":"KotlinJava <pre><code>@Component\nclass OrderHandlers {\n    // Typed handler - processes specific payload type\n    @OutboxHandler\n    fun handleOrder(payload: OrderCreatedEvent) {\n        eventPublisher.publish(payload)\n    }\n\n    // Generic handler - processes any payload type\n    @OutboxHandler\n    fun handleAny(payload: Any, metadata: OutboxRecordMetadata) {\n        when (payload) {\n            is OrderCreatedEvent -&gt; eventPublisher.publish(payload)\n            is PaymentProcessedEvent -&gt; paymentService.process(payload)\n            else -&gt; logger.warn(\"Unknown payload type\")\n        }\n    }\n}\n</code></pre> <pre><code>@Component\npublic class OrderHandlers {\n    // Typed handler - processes specific payload type\n    @OutboxHandler\n    public void handleOrder(OrderCreatedEvent payload) {\n        eventPublisher.publish(payload);\n    }\n\n    // Generic handler - processes any payload type\n    @OutboxHandler\n    public void handleAny(Object payload, OutboxRecordMetadata metadata) {\n        if (payload instanceof OrderCreatedEvent) {\n            eventPublisher.publish((OrderCreatedEvent) payload);\n        } else if (payload instanceof PaymentProcessedEvent) {\n            paymentService.process((PaymentProcessedEvent) payload);\n        } else {\n            logger.warn(\"Unknown payload type\");\n        }\n    }\n}\n</code></pre>"},{"location":"quickstart/#schedule-records-atomically","title":"Schedule Records Atomically","text":"KotlinJava <pre><code>@Service\nclass OrderService(\n    private val outbox: Outbox,\n    private val orderRepository: OrderRepository\n) {\n    @Transactional\n    fun createOrder(command: CreateOrderCommand) {\n        val order = Order.create(command)\n        orderRepository.save(order)\n\n        // Schedule event - saved atomically with the order\n        outbox.schedule(\n            payload = OrderCreatedEvent(order.id, order.customerId),\n            key = \"order-${order.id}\"  // Groups records for ordered processing\n        )\n    }\n}\n</code></pre> <pre><code>@Service\npublic class OrderService {\n    private final Outbox outbox;\n    private final OrderRepository orderRepository;\n\n    public OrderService(Outbox outbox, OrderRepository orderRepository) {\n        this.outbox = outbox;\n        this.orderRepository = orderRepository;\n    }\n\n    @Transactional\n    public void createOrder(CreateOrderCommand command) {\n        Order order = Order.create(command);\n        orderRepository.save(order);\n\n        // Schedule event - saved atomically with the order\n        outbox.schedule(\n            new OrderCreatedEvent(order.getId(), order.getCustomerId()),\n            \"order-\" + order.getId()  // Groups records for ordered processing\n        );\n    }\n}\n</code></pre>"},{"location":"quickstart/#alternative-using-springs-applicationeventpublisher","title":"Alternative: Using Spring's ApplicationEventPublisher","text":"<p>If you prefer Spring's native event publishing, annotate your events with <code>@OutboxEvent</code>:</p> KotlinJava <pre><code>@OutboxEvent(\n    key = \"#this.orderId\",  // SpEL: uses 'orderId' field\n    context = [\n        OutboxContextEntry(key = \"customerId\", value = \"#this.customerId\"),\n        OutboxContextEntry(key = \"region\", value = \"#this.region\")\n    ]\n)\ndata class OrderCreatedEvent(\n    val orderId: String,\n    val customerId: String,\n    val region: String,\n    val amount: BigDecimal\n)\n\n@Service\nclass OrderService(\n    private val orderRepository: OrderRepository,\n    private val eventPublisher: ApplicationEventPublisher\n) {\n    @Transactional\n    fun createOrder(command: CreateOrderCommand) {\n        val order = Order.create(command)\n        orderRepository.save(order)\n\n        // Publish event - automatically saved to outbox atomically\n        eventPublisher.publishEvent(\n            OrderCreatedEvent(order.id, order.customerId, order.region, order.amount)\n        )\n    }\n}\n</code></pre> <pre><code>@OutboxEvent(\n    key = \"#this.orderId\",  // SpEL: uses 'orderId' field\n    context = {\n        @OutboxContextEntry(key = \"customerId\", value = \"#this.customerId\"),\n        @OutboxContextEntry(key = \"region\", value = \"#this.region\")\n    }\n)\npublic class OrderCreatedEvent {\n    private String orderId;\n    private String customerId;\n    private String region;\n    private BigDecimal amount;\n    // constructor, getters...\n}\n\n@Service\npublic class OrderService {\n    private final OrderRepository orderRepository;\n    private final ApplicationEventPublisher eventPublisher;\n\n    public OrderService(OrderRepository orderRepository, \n                       ApplicationEventPublisher eventPublisher) {\n        this.orderRepository = orderRepository;\n        this.eventPublisher = eventPublisher;\n    }\n\n    @Transactional\n    public void createOrder(CreateOrderCommand command) {\n        Order order = Order.create(command);\n        orderRepository.save(order);\n\n        // Publish event - automatically saved to outbox atomically\n        eventPublisher.publishEvent(\n            new OrderCreatedEvent(order.getId(), order.getCustomerId(), \n                                 order.getRegion(), order.getAmount())\n        );\n    }\n}\n</code></pre> <p>Both approaches work equally well. Choose based on your preference:</p> <ul> <li>Explicit <code>outbox.schedule()</code>: More control, clearer intent, supports any payload type</li> <li><code>@OutboxEvent</code> + <code>ApplicationEventPublisher</code>: More Spring idiomatic for domain events</li> </ul>"},{"location":"quickstart/#configure-optional","title":"Configure (Optional)","text":"YAMLProperties <pre><code>namastack:\n  outbox:\n    poll-interval: 2000\n    batch-size: 10\n    retry:\n      policy: \"exponential\"\n      max-retries: 3\n      exponential:\n        initial-delay: 1000\n        max-delay: 60000\n        multiplier: 2.0\n</code></pre> <pre><code>namastack.outbox.poll-interval=2000\nnamastack.outbox.batch-size=10\nnamastack.outbox.retry.policy=exponential\nnamastack.outbox.retry.max-retries=3\nnamastack.outbox.retry.exponential.initial-delay=1000\nnamastack.outbox.retry.exponential.max-delay=60000\nnamastack.outbox.retry.exponential.multiplier=2.0\n</code></pre> <p>For a complete list of all configuration options, see Configuration Reference.</p> <p>That's it! Your records are now reliably persisted and processed.</p>"},{"location":"quickstart/#key-features","title":"Key Features","text":"<ul> <li>\u2705 Transactional Atomicity: Records saved in same transaction as domain data</li> <li>\u2705 Zero Message Loss: Database-backed with at-least-once delivery</li> <li>\u2705 Horizontal Scaling: Automatic partition assignment across instances</li> <li>\u2705 Automatic Retry: Exponential backoff, fixed delay, linear with optional jitter</li> <li>\u2705 Handler-Based: Annotation-based or interface-based handler registration</li> <li>\u2705 Type-Safe Handlers: Generic or typed handler support</li> <li>\u2705 Fallback Handlers: Graceful degradation when retries are exhausted</li> <li>\u2705 Flexible Payloads: Store any type - events, commands, notifications, etc.</li> <li>\u2705 Context Propagation: Trace IDs, tenant info, correlation IDs across async boundaries</li> <li>\u2705 Ordered Processing: Records with same key processed sequentially</li> <li>\u2705 Built-in Metrics: Micrometer integration for monitoring</li> </ul>"},{"location":"quickstart/#supported-databases","title":"Supported Databases","text":"<p>Any JPA/JDBC-compatible database is supported. Automatic schema creation is available in the JDBC module for:</p> <ul> <li>\u2705 H2 (development)</li> <li>\u2705 MySQL / MariaDB</li> <li>\u2705 PostgreSQL</li> <li>\u2705 SQL Server</li> </ul> <p>Schema Files for Flyway/Liquibase:</p> <p>If you manage your database schema manually, you can find the SQL schema files here: \ud83d\udc49 Schema Files on GitHub</p>"},{"location":"quickstart/#jpa-setup","title":"JPA Setup","text":"<p>If you prefer using JPA/Hibernate instead of JDBC:</p> GradleMaven <pre><code>dependencies {\n    implementation(\"io.namastack:namastack-outbox-starter-jpa:1.0.0\")\n}\n</code></pre> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.namastack&lt;/groupId&gt;\n    &lt;artifactId&gt;namastack-outbox-starter-jpa&lt;/artifactId&gt;\n    &lt;version&gt;1.0.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Schema Management Required</p> <p>The JPA module does not support automatic schema creation. Choose one of these options:</p> <p>Option 1: Hibernate DDL Auto (Development only) <pre><code>spring:\n  jpa:\n    hibernate:\n      ddl-auto: create  # or create-drop\n</code></pre></p> <p>Option 2: Flyway/Liquibase (Recommended for Production)</p> <p>Use the SQL schema files from our repository and configure Hibernate to validate: <pre><code>spring:\n  jpa:\n    hibernate:\n      ddl-auto: validate\n</code></pre></p>"},{"location":"quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Explore the Features Guide for advanced capabilities</li> <li>Check out the API Reference for detailed documentation</li> <li>Report issues at GitHub Issues</li> <li>Join GitHub Discussions for community support</li> </ul>"},{"location":"features/","title":"Features Overview","text":"<ul> <li> <p> Core Features</p> <p>Transactional outbox pattern, record ordering, and hash-based partitioning for horizontal scaling.</p> <p> Core Features</p> </li> <li> <p> Record Scheduling</p> <p>Schedule records via the Outbox Service API or use Spring's event system with @OutboxEvent.</p> <p> Scheduling</p> </li> <li> <p> Processing Chain</p> <p>Chain of Responsibility pattern for processing records through multiple stages.</p> <p> Processing</p> </li> <li> <p> Handlers</p> <p>Type-safe and generic handlers for processing outbox records, including fallback handlers for graceful degradation.</p> <p> Handlers</p> </li> <li> <p> Context Propagation</p> <p>Preserve trace IDs, tenant info, and other metadata across async boundaries.</p> <p> Context Propagation</p> </li> <li> <p> Serialization</p> <p>Flexible payload serialization with Jackson or custom serializers.</p> <p> Serialization</p> </li> <li> <p> Retry Mechanisms</p> <p>Sophisticated retry strategies with exponential backoff, jitter, and exception filtering.</p> <p> Retry Mechanisms</p> </li> <li> <p> Persistence</p> <p>Choose between JPA and JDBC persistence modules.</p> <p> Persistence</p> </li> <li> <p> Monitoring</p> <p>Built-in metrics with Micrometer and Spring Boot Actuator integration.</p> <p> Monitoring</p> </li> <li> <p> Configuration</p> <p>Complete reference of all configuration options.</p> <p> Configuration</p> </li> </ul> <p>Additional Topics</p> <ul> <li>Virtual Threads Support - Automatic virtual threads integration for better scalability</li> <li>Database Support - Supported databases and schema management</li> <li>Reliability Guarantees - What the library guarantees and what it doesn't</li> </ul> <p>Getting Started</p> <p>If you're new to Namastack Outbox, start with the Quick Start Guide to get up and running quickly.</p>"},{"location":"features/configuration/","title":"Configuration Reference","text":"<p>Complete reference of all configuration options:</p> <pre><code>namastack:\n  outbox:\n    enabled: true                              # Enable outbox functionality (default: true)\n\n    # Polling Configuration\n    poll-interval: 2000                        # Milliseconds between polling cycles (default: 2000)\n    rebalance-interval: 10000                  # Milliseconds between rebalance checks (default: 10000)\n    batch-size: 10                             # Records per poll cycle (default: 10)\n\n    # Processing Configuration\n    processing:\n      stop-on-first-failure: true              # Stop processing on first failure (default: true)\n      publish-after-save: true                 # Publish events to listeners after saving (default: true)\n      delete-completed-records: false          # Delete records after completion (default: false)\n      executor-core-pool-size: 4               # Core threads for processing (default: 4, platform threads)\n      executor-max-pool-size: 8                # Maximum threads for processing (default: 8, platform threads)\n      executor-concurrency-limit: -1           # Concurrency limit for virtual threads (default: -1 unlimited)\n\n    # Event Multicaster Configuration\n    multicaster:\n      enabled: true                            # Enable @OutboxEvent interception (default: true)\n\n    # Instance Coordination Configuration\n    instance:\n      graceful-shutdown-timeout-seconds: 0     # Graceful shutdown propagation window (default: 0)\n      stale-instance-timeout-seconds: 30       # When an instance is considered stale and removed (default: 30)\n      heartbeat-interval-seconds: 5            # How often each instance sends a heartbeat (default: 5)\n      rebalance-interval: 10000                # How often partitions are recalculated (default: 10000)\n\n    jdbc:\n      table-prefix: \"\"                         # Prefix for table names (default: empty)\n      schema-name: null                        # Database schema name (default: null, uses default schema)\n      schema-initialization:\n        enabled: true                          # Auto-create tables on startup (default: true)\n\n    # Retry Configuration\n    retry:\n      policy: exponential                      # Retry policy: fixed|linear|exponential (default: exponential)\n      max-retries: 3                           # Maximum retry attempts (default: 3)\n\n      # Exception Filtering (Since 1.0.0)\n      include-exceptions:                      # Only retry these exceptions (optional)\n        - java.net.SocketTimeoutException\n        - org.springframework.web.client.ResourceAccessException\n      exclude-exceptions:                      # Never retry these exceptions (optional)\n        - java.lang.IllegalArgumentException\n        - javax.validation.ValidationException\n\n      # Fixed Delay Policy\n      fixed:\n        delay: 5000                            # Delay in milliseconds (default: 5000)\n\n      # Linear Backoff Policy\n      linear:\n        initial-delay: 2000                    # Initial delay in milliseconds (default: 2000)\n        increment: 2000                        # Increment per retry in milliseconds (default: 2000)\n        max-delay: 60000                       # Maximum delay cap in milliseconds (default: 60000)\n\n      # Exponential Backoff Policy\n      exponential:\n        initial-delay: 1000                    # Initial delay in milliseconds (default: 1000)\n        max-delay: 60000                       # Maximum delay cap in milliseconds (default: 60000)\n        multiplier: 2.0                        # Backoff multiplier (default: 2.0)\n\n      # Jitter Configuration (can be used with any policy)\n      jitter: 0                                # Max random jitter in milliseconds (default: 0)\n</code></pre>"},{"location":"features/configuration/#disabling-outbox","title":"Disabling Outbox","text":"<p>To completely disable outbox functionality:</p> <pre><code>namastack:\n  outbox:\n    enabled: false\n</code></pre> <p>This prevents all outbox beans from being created, useful for:</p> <ul> <li>Running tests without outbox processing</li> <li>Temporarily disabling outbox in specific environments</li> <li>Conditional feature flags</li> </ul>"},{"location":"features/context-propagation/","title":"Context Propagation","text":"<p>Cross-Boundary Context (Since 1.0.0)</p> <p>Context propagation preserves important metadata (trace IDs, tenant info, correlation IDs, user context) across the async boundary between scheduling and processing.</p>"},{"location":"features/context-propagation/#how-it-works","title":"How It Works","text":"<p>Context is captured when records are scheduled and restored when handlers are invoked:</p> <pre><code>sequenceDiagram\n    participant App as Application\n    participant CP as OutboxContextProvider\n    participant DB as Outbox Table\n    participant Scheduler as Scheduler\n    participant Handler as Handler\n\n    App-&gt;&gt;CP: Request current context\n    CP--&gt;&gt;App: {traceId, spanId, tenantId}\n    App-&gt;&gt;DB: Save record + context\n    Note over DB: Context stored as JSON\n\n    Scheduler-&gt;&gt;DB: Poll records\n    DB--&gt;&gt;Scheduler: Record + context\n    Scheduler-&gt;&gt;Handler: Invoke with metadata\n    Note over Handler: Context available via&lt;br/&gt;metadata.context</code></pre>"},{"location":"features/context-propagation/#outboxcontextprovider-interface","title":"OutboxContextProvider Interface","text":"<p>Implement <code>OutboxContextProvider</code> to capture context during record scheduling:</p> KotlinJava <pre><code>@Component\nclass TracingContextProvider(\n    private val tracer: Tracer\n) : OutboxContextProvider {\n    override fun provide(): Map&lt;String, String&gt; {\n        val currentSpan = tracer.currentSpan() ?: return emptyMap()\n        return mapOf(\n            \"traceId\" to currentSpan.context().traceId(),\n            \"spanId\" to currentSpan.context().spanId()\n        )\n    }\n}\n\n@Component\nclass TenantContextProvider : OutboxContextProvider {\n    override fun provide(): Map&lt;String, String&gt; {\n        val tenantId = SecurityContextHolder.getContext()\n            .authentication\n            ?.principal\n            ?.let { (it as? TenantAware)?.tenantId }\n            ?: return emptyMap()\n\n        return mapOf(\"tenantId\" to tenantId)\n    }\n}\n</code></pre> <pre><code>@Component\npublic class TracingContextProvider implements OutboxContextProvider {\n    private final Tracer tracer;\n\n    public TracingContextProvider(Tracer tracer) {\n        this.tracer = tracer;\n    }\n\n    @Override\n    public Map&lt;String, String&gt; provide() {\n        Span currentSpan = tracer.currentSpan();\n        if (currentSpan == null) {\n            return Collections.emptyMap();\n        }\n\n        return Map.of(\n            \"traceId\", currentSpan.context().traceId(),\n            \"spanId\", currentSpan.context().spanId()\n        );\n    }\n}\n\n@Component\npublic class TenantContextProvider implements OutboxContextProvider {\n    @Override\n    public Map&lt;String, String&gt; provide() {\n        Authentication auth = SecurityContextHolder.getContext().getAuthentication();\n        if (auth == null || !(auth.getPrincipal() instanceof TenantAware)) {\n            return Collections.emptyMap();\n        }\n\n        String tenantId = ((TenantAware) auth.getPrincipal()).getTenantId();\n        return Map.of(\"tenantId\", tenantId);\n    }\n}\n</code></pre> <p>Multiple Providers:</p> <p>You can register multiple <code>OutboxContextProvider</code> beans. The library automatically merges all context maps. If keys collide, the last provider wins.</p>"},{"location":"features/context-propagation/#accessing-context-in-handlers","title":"Accessing Context in Handlers","text":"<p>Context is available via <code>metadata.context</code> in primary handlers and <code>failureContext.context</code> in fallback handlers:</p> KotlinJava <pre><code>@Component\nclass OrderHandler {\n    @OutboxHandler\n    fun handle(payload: OrderEvent, metadata: OutboxRecordMetadata) {\n        // Access context via metadata.context\n        val traceId = metadata.context[\"traceId\"]\n        val spanId = metadata.context[\"spanId\"]\n        val tenantId = metadata.context[\"tenantId\"]\n\n        // Restore tracing context for downstream calls\n        tracer.withSpan(traceId, spanId) {\n            logger.info(\"Processing order ${payload.orderId} [trace: $traceId]\")\n            orderService.process(payload)\n        }\n    }\n\n    @OutboxFallbackHandler\n    fun handleFailure(payload: OrderEvent, context: OutboxFailureContext) {\n        // Access context via failureContext.context\n        val traceId = context.context[\"traceId\"]\n\n        logger.error(\n            \"Order ${payload.orderId} failed permanently [trace: $traceId]\",\n            context.lastException\n        )\n\n        deadLetterQueue.publish(\n            payload = payload,\n            context = mapOf(\"traceId\" to traceId)\n        )\n    }\n}\n</code></pre> <pre><code>@Component\npublic class OrderHandler {\n    @OutboxHandler\n    public void handle(OrderEvent payload, OutboxRecordMetadata metadata) {\n        // Access context via metadata.context\n        String traceId = metadata.getContext().get(\"traceId\");\n        String spanId = metadata.getContext().get(\"spanId\");\n        String tenantId = metadata.getContext().get(\"tenantId\");\n\n        // Restore tracing context for downstream calls\n        tracer.withSpan(traceId, spanId, () -&gt; {\n            logger.info(\"Processing order {} [trace: {}]\", payload.getOrderId(), traceId);\n            orderService.process(payload);\n        });\n    }\n\n    @OutboxFallbackHandler\n    public void handleFailure(OrderEvent payload, OutboxFailureContext context) {\n        // Access context via failureContext.context\n        String traceId = context.getContext().get(\"traceId\");\n\n        logger.error(\n            \"Order {} failed permanently [trace: {}]\",\n            payload.getOrderId(),\n            traceId,\n            context.getLastException()\n        );\n\n        deadLetterQueue.publish(payload, Map.of(\"traceId\", traceId));\n    }\n}\n</code></pre>"},{"location":"features/context-propagation/#manual-context-override","title":"Manual Context Override","text":"<p>You can also pass custom context directly when scheduling records:</p> KotlinJava <pre><code>@Service\nclass OrderService(private val outbox: Outbox) {\n    @Transactional\n    fun createOrder(command: CreateOrderCommand) {\n        val order = Order.create(command)\n        orderRepository.save(order)\n\n        // Override or extend context\n        outbox.schedule(\n            payload = OrderCreatedEvent(order.id, order.customerId),\n            key = \"order-${order.id}\",\n            context = mapOf(\n                \"correlationId\" to command.correlationId,\n                \"userId\" to command.userId,\n                \"priority\" to \"high\"\n            )\n        )\n    }\n}\n</code></pre> <pre><code>@Service\npublic class OrderService {\n    private final Outbox outbox;\n\n    @Transactional\n    public void createOrder(CreateOrderCommand command) {\n        Order order = Order.create(command);\n        orderRepository.save(order);\n\n        // Override or extend context\n        outbox.schedule(\n            new OrderCreatedEvent(order.getId()),\n            \"order-\" + order.getId(),\n            Map.of(\n                \"correlationId\", command.getCorrelationId(),\n                \"userId\", command.getUserId(),\n                \"priority\", \"high\"\n            )\n        );\n    }\n}\n</code></pre> <p>Context Merging:</p> <p>When you provide manual context, it's merged with context from registered <code>OutboxContextProvider</code> beans. Manual context takes precedence for duplicate keys.</p>"},{"location":"features/context-propagation/#use-cases","title":"Use Cases","text":"<p>Common use cases for context propagation:</p> <ol> <li>Distributed Tracing: Preserve trace and span IDs across async boundaries</li> <li>Multi-Tenancy: Maintain tenant context for data isolation</li> <li>Correlation IDs: Track requests across service boundaries</li> <li>User Context: Preserve user identity for audit logging</li> <li>Feature Flags: Propagate feature flag states for consistent behavior</li> <li>Request Metadata: Pass request IDs, client info, API versions</li> </ol>"},{"location":"features/core/","title":"Core Features","text":""},{"location":"features/core/#transactional-outbox-pattern","title":"Transactional Outbox Pattern","text":"<p>Zero Message Loss</p> <p>The library ensures that domain records are never lost by storing them in the same database transaction as your business data. This guarantees consistency between your domain state and persisted records.</p>"},{"location":"features/core/#benefits","title":"Benefits","text":"<ul> <li>ACID Compliance: Records are saved atomically with business data</li> <li>Consistency Guarantee: No partial updates or lost records</li> <li>Failure Recovery: System crashes don't result in data loss</li> <li>Reliable Processing: Records are processed with automatic retry logic</li> </ul>"},{"location":"features/core/#how-it-works","title":"How it Works","text":"<pre><code>sequenceDiagram\n    participant A as Application\n    participant DB as Entity Table\n    participant O as Outbox Table\n    participant S as Scheduler\n    participant P as Handler\n\n    A-&gt;&gt;DB: Begin Transaction\n    A-&gt;&gt;DB: Save Business Data\n    A-&gt;&gt;O: Save Record\n    DB-&gt;&gt;A: Commit Transaction\n    S-&gt;&gt;O: Poll Records\n    S-&gt;&gt;P: Invoke Handler\n    P-&gt;&gt;P: Process Record\n    S-&gt;&gt;O: Mark Complete</code></pre>"},{"location":"features/core/#record-ordering","title":"Record Ordering","text":"<p>Guaranteed Processing Order</p> <p>Records with the same key are always processed in creation order, ensuring business logic consistency and preventing race conditions.</p> <p>Key Benefits:</p> <ul> <li> Aggregate Consistency: Records with the same key maintain order</li> <li> Business Logic Safety: Dependent records process in correct sequence  </li> <li> Parallel Processing: Different keys process independently</li> <li> Scalable Design: No global ordering bottlenecks</li> </ul>"},{"location":"features/core/#controlling-failure-behavior","title":"Controlling Failure Behavior","text":"<p>Control how the scheduler handles failures within a key sequence:</p> <p>Stop on First Failure Configuration</p> Enabled (Default)Disabled <pre><code>namastack:\n  outbox:\n    processing:\n      stop-on-first-failure: true\n</code></pre> <p>Behavior: - When one record fails, processing stops for remaining records with the same key - Maintains strict ordering within key sequences - Prevents cascading issues from dependent records - Recommended: When records within a key have dependencies</p> <pre><code>namastack:\n  outbox:\n    processing:\n      stop-on-first-failure: false\n</code></pre> <p>Behavior: - Failed records don't block independent records with the same key - Maximizes throughput for independent records - Recommended: When records within a key are independent</p> <p>Behavior Comparison:</p> Configuration Record 1 Record 2 Record 3 Result <code>true</code> (default)  Success  Fails  Skipped Record 2 retried, Record 3 waits <code>false</code>  Success  Fails  Success Record 2 retried independently"},{"location":"features/core/#hash-based-partitioning","title":"Hash-based Partitioning","text":"<p>Instead of distributed locking, the library uses hash-based partitioning to enable horizontal scaling across multiple instances while maintaining strict record ordering per key. This approach eliminates lock contention and provides better performance.</p>"},{"location":"features/core/#how-partitioning-works","title":"How Partitioning Works","text":"<pre><code>graph TB\n    A[\"Key: order-123\"] --&gt; H[MurmurHash3]\n    H --&gt; P[Partition 42]\n    P --&gt; I1[Instance 1]\n\n    B[\"Key: user-456\"] --&gt; H2[MurmurHash3]\n    H2 --&gt; P2[Partition 128]\n    P2 --&gt; I2[Instance 2]\n\n    C[\"Key: order-789\"] --&gt; H3[MurmurHash3]\n    H3 --&gt; P3[Partition 42]\n    P3 --&gt; I1\n\n    subgraph \"256 Fixed Partitions\"\n        P\n        P2\n        P3[\"...other partitions\"]\n    end\n\n    subgraph \"Dynamic Instance Assignment\"\n        I1[\"Instance 1: Partitions 0-127\"]\n        I2[\"Instance 2: Partitions 128-255\"]\n    end</code></pre>"},{"location":"features/core/#key-benefits","title":"Key Benefits","text":"<ul> <li>Consistent Hashing: Each key always maps to the same partition using MurmurHash3</li> <li>No Lock Contention: Eliminates distributed lock overhead and deadlock risks</li> <li>Horizontal Scaling: Partitions automatically redistribute when instances join/leave</li> <li>Load Balancing: Even distribution of partitions across all active instances</li> <li>Ordering Guarantee: Records within the same key process in strict order</li> <li>Better Performance: No lock acquisition/renewal overhead</li> </ul>"},{"location":"features/core/#partition-assignment","title":"Partition Assignment","text":"<p>256 fixed partitions provide fine-grained load distribution. Partitions are automatically distributed among active instances. Each key always maps to the same partition.</p> KotlinJava <pre><code>val partition = PartitionHasher.getPartitionForAggregate(\"order-123\")\n</code></pre> <pre><code>int partition = PartitionHasher.getPartitionForAggregate(\"order-123\");\n</code></pre>"},{"location":"features/core/#instance-coordination","title":"Instance Coordination","text":"<p>Instances automatically coordinate partition assignments and rebalance when topology changes. Configuration controls how aggressive this coordination is:</p> <pre><code>namastack:\n  outbox:\n    instance:\n      heartbeat-interval-seconds: 5            # How often each instance sends a heartbeat\n      stale-instance-timeout-seconds: 30       # When an instance is considered stale and removed\n      graceful-shutdown-timeout-seconds: 0     # Optional: propagation window on shutdown (default: 0)\n      rebalance-interval: 10000                # How often partitions are recalculated\n</code></pre> <p>Scaling Behavior</p> 3 Instances with 256 PartitionsInstance 2 Goes DownNew Instance Joins <pre><code>Instance 1: Partitions 0-84   (85 partitions)\nInstance 2: Partitions 85-169 (85 partitions) \nInstance 3: Partitions 170-255 (86 partitions)\n</code></pre> <pre><code>Instance 1: Partitions 0-84, 170-211   (127 partitions)\nInstance 3: Partitions 85-169, 212-255 (129 partitions)\n</code></pre> <p>\ud83d\udd04 Automatic Rebalancing: Partitions from failed instances are redistributed</p> <pre><code>Instance 1: Partitions 0-63    (64 partitions)\nInstance 2: Partitions 64-127  (64 partitions)\nInstance 3: Partitions 128-191 (64 partitions)\nInstance 4: Partitions 192-255 (64 partitions)\n</code></pre> <p>\u2696\ufe0f Load Balancing: Partitions are redistributed evenly</p>"},{"location":"features/database/","title":"Database Support","text":""},{"location":"features/database/#supported-databases","title":"Supported Databases","text":"<p>Any JPA/JDBC-compatible database is supported. Automatic schema creation (JDBC module only) is available for:</p> <ul> <li>\u2705 H2 (development)</li> <li>\u2705 MySQL / MariaDB</li> <li>\u2705 PostgreSQL</li> <li>\u2705 SQL Server</li> </ul>"},{"location":"features/database/#schema-management","title":"Schema Management","text":""},{"location":"features/database/#jdbc-module","title":"JDBC Module","text":"<p>The JDBC module automatically creates its schema on startup by default. You can disable it:</p> <pre><code>namastack:\n  outbox:\n    jdbc:\n      schema-initialization:\n        enabled: false\n</code></pre>"},{"location":"features/database/#jpa-module","title":"JPA Module","text":"<p>The JPA module does not support automatic schema creation. Use one of these approaches:</p> <p>Option 1: Hibernate DDL Auto (Development) <pre><code>spring:\n  jpa:\n    hibernate:\n      ddl-auto: create  # or create-drop, update\n</code></pre></p> <p>Option 2: Flyway/Liquibase (Production)</p> <p>Create tables manually using migration scripts. Database-specific schemas are available: \ud83d\udc49 Schema Files on GitHub</p> <p>Then configure Hibernate to validate the schema: <pre><code>spring:\n  jpa:\n    hibernate:\n      ddl-auto: validate\n</code></pre></p>"},{"location":"features/guarantees/","title":"Reliability Guarantees","text":""},{"location":"features/guarantees/#what-namastack-outbox-for-spring-boot-guarantees","title":"What Namastack Outbox for Spring Boot Guarantees","text":"<ul> <li> At-least-once delivery: Records will be processed at least once</li> <li> Ordering per key: Records with the same key are processed in order</li> <li> Failure recovery: System failures don't result in lost records</li> <li> Horizontal scalability: Multiple instances process different partitions</li> <li> Consistency: Database transactions ensure data integrity</li> <li> Automatic retry: Failed records are automatically retried</li> <li> Automatic rebalancing: Partitions redistribute on topology changes</li> <li> Linear scaling: Performance scales with instance count</li> </ul>"},{"location":"features/guarantees/#what-namastack-outbox-for-spring-boot-does-not-guarantee","title":"What Namastack Outbox for Spring Boot Does NOT Guarantee","text":"<ul> <li> Exactly-once delivery: Records may be processed multiple times (handlers should be idempotent)</li> <li> Global ordering: No ordering guarantee across different keys</li> <li> Real-time processing: Records are processed asynchronously with configurable delays</li> </ul> <p>Next Steps</p> <p>Ready to get started? Check out the Quick Start Guide to integrate Namastack Outbox for Spring Boot into your application.</p>"},{"location":"features/handlers/","title":"Handlers","text":""},{"location":"features/handlers/#handler-types-interfaces","title":"Handler Types &amp; Interfaces","text":"<p>The library provides two complementary handler interfaces for different use cases:</p>"},{"location":"features/handlers/#typed-handlers-type-safe","title":"Typed Handlers (Type-Safe)","text":"<p>Process specific payload types with full type safety. Recommended for most cases as handlers are type-checked at compile time.</p> KotlinJava <pre><code>@Component\nclass OrderCreatedHandler : OutboxTypedHandler&lt;OrderCreatedRecord&gt; {\n    override fun handle(payload: OrderCreatedRecord) {\n        println(\"Processing order: ${payload.orderId}\")\n        eventPublisher.publish(payload)\n    }\n}\n</code></pre> <pre><code>@Component\npublic class OrderCreatedHandler implements OutboxTypedHandler&lt;OrderCreatedRecord&gt; {\n    @Override\n    public void handle(OrderCreatedRecord payload) {\n        System.out.println(\"Processing order: \" + payload.getOrderId());\n        eventPublisher.publish(payload);\n    }\n}\n</code></pre>"},{"location":"features/handlers/#generic-handlers-multi-type","title":"Generic Handlers (Multi-Type)","text":"<p>Process any payload type with pattern matching. Use for catch-all or multi-type routing logic.</p> KotlinJava <pre><code>@Component\nclass UniversalHandler : OutboxHandler {\n    override fun handle(payload: Any, metadata: OutboxRecordMetadata) {\n        when (payload) {\n            is OrderCreatedRecord -&gt; handleOrder(payload)\n            is PaymentProcessedRecord -&gt; handlePayment(payload)\n            is CreateCustomerCommand -&gt; createCustomer(payload)\n            else -&gt; logger.warn(\"Unknown payload: ${payload::class.simpleName}\")\n        }\n    }\n}\n</code></pre> <pre><code>@Component\npublic class UniversalHandler implements OutboxHandler {\n    @Override\n    public void handle(Object payload, OutboxRecordMetadata metadata) {\n        if (payload instanceof OrderCreatedRecord) {\n            handleOrder((OrderCreatedRecord) payload);\n        } else if (payload instanceof PaymentProcessedRecord) {\n            handlePayment((PaymentProcessedRecord) payload);\n        } else if (payload instanceof CreateCustomerCommand) {\n            createCustomer((CreateCustomerCommand) payload);\n        } else {\n            logger.warn(\"Unknown payload: {}\", payload.getClass().getSimpleName());\n        }\n    }\n}\n</code></pre>"},{"location":"features/handlers/#handler-invocation-order","title":"Handler Invocation Order","text":"<p>When multiple handlers are registered:</p> <ol> <li>All matching typed handlers are invoked first (in registration order)</li> <li>All generic handlers are invoked second (catch-all)</li> </ol>"},{"location":"features/handlers/#annotation-based-handlers","title":"Annotation-based Handlers","text":"<p>Use <code>@OutboxHandler</code> annotation for method-level handler registration as an alternative to implementing interfaces:</p> KotlinJava <pre><code>@Component\nclass MyHandlers {\n    @OutboxHandler\n    fun handleOrderCreated(payload: OrderCreatedRecord) {\n        // ...\n    }\n\n    @OutboxHandler\n    fun handlePaymentProcessed(payload: PaymentProcessedRecord) {\n        // ...\n    }\n\n    @OutboxHandler\n    fun handleAny(payload: Any, metadata: OutboxRecordMetadata) {\n        // Generic handler via annotation\n    }\n}\n</code></pre> <pre><code>@Component\npublic class MyHandlers {\n    @OutboxHandler\n    public void handleOrderCreated(OrderCreatedRecord payload) {\n        // ...\n    }\n\n    @OutboxHandler\n    public void handlePaymentProcessed(PaymentProcessedRecord payload) {\n        // ...\n    }\n\n    @OutboxHandler\n    public void handleAny(Object payload, OutboxRecordMetadata metadata) {\n        // Generic handler via annotation\n    }\n}\n</code></pre> <p>Handler Signature Requirements</p> <ul> <li>Typed handlers can accept 1 or 2 parameters:<ul> <li><code>fun handle(payload: T)</code> - Payload only</li> <li><code>fun handle(payload: T, metadata: OutboxRecordMetadata)</code> - Payload + metadata</li> </ul> </li> <li>Generic handlers must accept 2 parameters:<ul> <li><code>fun handle(payload: Any, metadata: OutboxRecordMetadata)</code> - Required signature</li> </ul> </li> </ul> <p>Interface vs Annotation:</p> <ul> <li>Interfaces: Best when entire class is dedicated to handling a single type</li> <li>Annotations: Best when a class handles multiple types or mixing with other logic</li> </ul>"},{"location":"features/handlers/#fallback-handlers","title":"Fallback Handlers","text":"<p>Graceful Degradation (Since 1.0.0)</p> <p>Fallback handlers provide a safety net when all retries are exhausted, allowing for compensating actions, dead letter queue publishing, or alternative processing strategies.</p> <p>Fallback handlers are automatically invoked when:</p> <ul> <li>Retries Exhausted: The record has exceeded the maximum retry count</li> <li>Non-Retryable Exceptions: An exception is thrown that should not be retried (based on retry policy)</li> </ul>"},{"location":"features/handlers/#interface-based-fallback-handlers","title":"Interface-Based Fallback Handlers","text":"<p>Implement <code>OutboxFallbackHandler</code> interface for type-safe fallback handling:</p> KotlinJava <pre><code>@Component\nclass OrderFallbackHandler : OutboxFallbackHandler&lt;OrderEvent&gt; {\n    override fun handle(payload: OrderEvent, context: OutboxFailureContext) {\n        logger.error(\n            \"Order ${payload.orderId} failed permanently after ${context.failureCount} attempts\",\n            context.lastException\n        )\n\n        // Publish to dead letter queue\n        deadLetterQueue.publish(\n            payload = payload,\n            reason = \"Max retries exceeded\",\n            exception = context.lastException,\n            traceId = context.context[\"traceId\"]\n        )\n\n        // Send alert\n        alertService.sendAlert(\n            \"Order processing failed permanently: ${payload.orderId}\"\n        )\n    }\n}\n</code></pre> <pre><code>@Component\npublic class OrderFallbackHandler implements OutboxFallbackHandler&lt;OrderEvent&gt; {\n    @Override\n    public void handle(OrderEvent payload, OutboxFailureContext context) {\n        logger.error(\n            \"Order {} failed permanently after {} attempts\",\n            payload.getOrderId(),\n            context.getFailureCount(),\n            context.getLastException()\n        );\n\n        // Publish to dead letter queue\n        deadLetterQueue.publish(\n            payload,\n            \"Max retries exceeded\",\n            context.getLastException(),\n            context.getContext().get(\"traceId\")\n        );\n\n        // Send alert\n        alertService.sendAlert(\n            \"Order processing failed permanently: \" + payload.getOrderId()\n        );\n    }\n}\n</code></pre>"},{"location":"features/handlers/#annotation-based-fallback-handlers","title":"Annotation-Based Fallback Handlers","text":"<p>Use <code>@OutboxFallbackHandler</code> annotation for method-level fallback registration:</p> KotlinJava <pre><code>@Component\nclass OrderHandlers {\n    @OutboxHandler\n    fun handleOrder(payload: OrderEvent) {\n        emailService.send(payload.email)  // May fail\n    }\n\n    @OutboxFallbackHandler\n    fun handleOrderFailure(payload: OrderEvent, context: OutboxFailureContext) {\n        logger.error(\n            \"Order ${payload.orderId} failed after ${context.failureCount} attempts\"\n        )\n        deadLetterQueue.publish(payload)\n    }\n}\n</code></pre> <pre><code>@Component\npublic class OrderHandlers {\n    @OutboxHandler\n    public void handleOrder(OrderEvent payload) {\n        emailService.send(payload.getEmail());  // May fail\n    }\n\n    @OutboxFallbackHandler\n    public void handleOrderFailure(OrderEvent payload, OutboxFailureContext context) {\n        logger.error(\n            \"Order {} failed after {} attempts\",\n            payload.getOrderId(),\n            context.getFailureCount()\n        );\n        deadLetterQueue.publish(payload);\n    }\n}\n</code></pre>"},{"location":"features/handlers/#outboxfailurecontext","title":"OutboxFailureContext","text":"<p>The <code>OutboxFailureContext</code> provides comprehensive failure information:</p> <pre><code>interface OutboxFailureContext {\n    val handlerId: String              // Handler that failed\n    val key: String                    // Record key\n    val createdAt: Instant            // When record was created\n    val failureCount: Int             // Number of failed attempts\n    val lastException: Throwable?     // Last exception thrown\n    val context: Map&lt;String, String&gt;  // Propagated context (traceId, tenantId, etc.)\n}\n</code></pre>"},{"location":"features/handlers/#fallback-behavior","title":"Fallback Behavior","text":"<p>Record Status After Fallback:</p> <ul> <li>Fallback Succeeds: Record marked as <code>COMPLETED</code></li> <li>Fallback Fails: Record marked as <code>FAILED</code> (requires manual intervention)</li> </ul> <p>Automatic Matching:</p> <p>Fallback handlers are automatically matched to primary handlers by payload type. One fallback handler can serve multiple primary handlers processing the same payload type.</p> KotlinJava <pre><code>@Component\nclass OrderHandlers {\n    // Both handlers share the same fallback\n    @OutboxHandler\n    fun handleOrderCreated(payload: OrderEvent) {\n        orderService.create(payload)\n    }\n\n    @OutboxHandler\n    fun handleOrderUpdated(payload: OrderEvent) {\n        orderService.update(payload)\n    }\n\n    @OutboxFallbackHandler\n    fun handleOrderFailure(payload: OrderEvent, context: OutboxFailureContext) {\n        // Handles failures from both handleOrderCreated and handleOrderUpdated\n        deadLetterQueue.publish(payload)\n    }\n}\n</code></pre> <pre><code>@Component\npublic class OrderHandlers {\n    // Both handlers share the same fallback\n    @OutboxHandler\n    public void handleOrderCreated(OrderEvent payload) {\n        orderService.create(payload);\n    }\n\n    @OutboxHandler\n    public void handleOrderUpdated(OrderEvent payload) {\n        orderService.update(payload);\n    }\n\n    @OutboxFallbackHandler\n    public void handleOrderFailure(OrderEvent payload, OutboxFailureContext context) {\n        // Handles failures from both handleOrderCreated and handleOrderUpdated\n        deadLetterQueue.publish(payload);\n    }\n}\n</code></pre> <p>Fallback Handler Requirements</p> <ul> <li>Only one fallback handler per payload type is supported</li> <li>Fallback handlers must match the payload type exactly</li> <li>Fallback signature: <code>fun handle(payload: T, context: OutboxFailureContext)</code></li> </ul>"},{"location":"features/handlers/#fallback-use-cases","title":"Fallback Use Cases","text":"<p>Common use cases for fallback handlers:</p> <ol> <li>Dead Letter Queue: Publish failed records to a DLQ for later analysis</li> <li>Alert &amp; Monitoring: Send alerts when records fail permanently</li> <li>Compensating Actions: Execute compensating transactions (e.g., refund, rollback)</li> <li>Alternative Processing: Route to alternative processing logic</li> <li>Audit Logging: Log failure details for compliance and debugging</li> </ol>"},{"location":"features/monitoring/","title":"Monitoring &amp; Observability","text":""},{"location":"features/monitoring/#metrics-module","title":"Metrics Module","text":"<p>The <code>namastack-outbox-metrics</code> module provides automatic integration with Spring Boot Actuator and Micrometer:</p> GradleMaven <pre><code>dependencies {\n    implementation(\"io.namastack:namastack-outbox-starter-jpa:1.0.0\")\n    implementation(\"io.namastack:namastack-outbox-metrics:1.0.0\")\n\n    // For Prometheus endpoint (optional)\n    implementation(\"io.micrometer:micrometer-registry-prometheus\")\n}\n</code></pre> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.namastack&lt;/groupId&gt;\n    &lt;artifactId&gt;namastack-outbox-metrics&lt;/artifactId&gt;\n    &lt;version&gt;1.0.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"features/monitoring/#built-in-metrics","title":"Built-in Metrics","text":"Metric Description Tags <code>outbox.records.count</code> Number of outbox records <code>status=new\\|failed\\|completed</code> <code>outbox.partitions.assigned.count</code> Partitions assigned to this instance - <code>outbox.partitions.pending.records.total</code> Total pending records across partitions - <code>outbox.partitions.pending.records.max</code> Maximum pending records in any partition - <code>outbox.cluster.instances.total</code> Total active instances in cluster - <p>Endpoints:</p> <ul> <li><code>/actuator/metrics/outbox.records.count</code></li> <li><code>/actuator/metrics/outbox.partitions.assigned.count</code></li> <li><code>/actuator/prometheus</code> (if Prometheus enabled)</li> </ul>"},{"location":"features/monitoring/#programmatic-monitoring","title":"Programmatic Monitoring","text":"KotlinJava <pre><code>@Service\nclass OutboxMonitoringService(\n    private val outboxRepository: OutboxRecordRepository,\n    private val partitionMetricsProvider: OutboxPartitionMetricsProvider\n) {\n    fun getPendingRecordCount(): Long =\n        outboxRepository.countByStatus(OutboxRecordStatus.NEW)\n\n    fun getFailedRecordCount(): Long =\n        outboxRepository.countByStatus(OutboxRecordStatus.FAILED)\n\n    fun getPartitionStats(): PartitionProcessingStats =\n        partitionMetricsProvider.getProcessingStats()\n\n    fun getClusterStats(): PartitionStats =\n        partitionMetricsProvider.getPartitionStats()\n}\n</code></pre> <pre><code>@Service\npublic class OutboxMonitoringService {\n    private final OutboxRecordRepository outboxRepository;\n    private final OutboxPartitionMetricsProvider partitionMetricsProvider;\n\n    public OutboxMonitoringService(OutboxRecordRepository outboxRepository,\n                                   OutboxPartitionMetricsProvider partitionMetricsProvider) {\n        this.outboxRepository = outboxRepository;\n        this.partitionMetricsProvider = partitionMetricsProvider;\n    }\n\n    public long getPendingRecordCount() {\n        return outboxRepository.countByStatus(OutboxRecordStatus.NEW);\n    }\n\n    public long getFailedRecordCount() {\n        return outboxRepository.countByStatus(OutboxRecordStatus.FAILED);\n    }\n\n    public PartitionProcessingStats getPartitionStats() {\n        return partitionMetricsProvider.getProcessingStats();\n    }\n\n    public PartitionStats getClusterStats() {\n        return partitionMetricsProvider.getPartitionStats();\n    }\n}\n</code></pre>"},{"location":"features/persistence/","title":"Persistence Modules","text":"<p>Namastack Outbox provides two persistence modules to choose from based on your needs.</p>"},{"location":"features/persistence/#jpa-module","title":"JPA Module","text":"<p>The JPA module uses Hibernate/JPA for database operations. Best for projects already using Spring Data JPA.</p> GradleMaven <pre><code>dependencies {\n    implementation(\"io.namastack:namastack-outbox-starter-jpa:1.0.0\")\n}\n</code></pre> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.namastack&lt;/groupId&gt;\n    &lt;artifactId&gt;namastack-outbox-starter-jpa&lt;/artifactId&gt;\n    &lt;version&gt;1.0.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Schema Management</p> <p>The JPA module does not support automatic schema creation. You must manage schemas using:</p> <ul> <li>Flyway/Liquibase (recommended for production) - Use the SQL schema files</li> <li>Hibernate DDL Auto (<code>ddl-auto: create</code>) for development</li> </ul>"},{"location":"features/persistence/#jdbc-module","title":"JDBC Module","text":"<p>The JDBC module uses Spring's <code>JdbcClient</code> for database operations. Best for projects that don't use JPA or want lower overhead.</p> GradleMaven <pre><code>dependencies {\n    implementation(\"io.namastack:namastack-outbox-starter-jdbc:1.0.0\")\n}\n</code></pre> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.namastack&lt;/groupId&gt;\n    &lt;artifactId&gt;namastack-outbox-starter-jdbc&lt;/artifactId&gt;\n    &lt;version&gt;1.0.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Benefits:</p> <ul> <li>No Hibernate/JPA dependency required</li> <li>Built-in automatic schema initialization</li> <li>Support for custom table prefixes and schema names</li> <li>Lower memory footprint</li> </ul>"},{"location":"features/persistence/#automatic-schema-creation-jdbc-only","title":"Automatic Schema Creation (JDBC Only)","text":"<p>The JDBC module automatically creates outbox tables on startup by default:</p> <pre><code>namastack:\n  outbox:\n    jdbc:\n      schema-initialization:\n        enabled: true  # Auto-create tables on startup (default: true)\n</code></pre> <p>Database Detection</p> <p>The JDBC module automatically detects your database type and uses the appropriate schema. Supported databases: PostgreSQL, MySQL, MariaDB, H2, SQL Server.</p>"},{"location":"features/persistence/#custom-table-prefix-and-schema-name","title":"Custom Table Prefix and Schema Name","text":"<p>The JDBC module supports custom table naming for multi-tenant deployments or naming conventions:</p> <pre><code>namastack:\n  outbox:\n    jdbc:\n      table-prefix: \"myapp_\"           # Results in: myapp_outbox_record, myapp_outbox_instance, etc.\n      schema-name: \"outbox_schema\"     # Results in: outbox_schema.myapp_outbox_record\n</code></pre> <p>Examples:</p> Configuration Resulting Table Name Default <code>outbox_record</code> <code>table-prefix: \"app1_\"</code> <code>app1_outbox_record</code> <code>schema-name: \"myschema\"</code> <code>myschema.outbox_record</code> Both <code>myschema.app1_outbox_record</code> <p>Schema Initialization Limitation</p> <p>When using custom table prefix or schema name, you must disable schema initialization (which is enabled by default). Schema initialization cannot be used with custom naming:</p> <pre><code>namastack:\n  outbox:\n    jdbc:\n      table-prefix: \"myapp_\"\n      schema-name: \"custom_schema\"\n      schema-initialization:\n        enabled: false  # Must be false when using custom naming\n</code></pre> <p>Manual Schema Creation:</p> <p>Use the SQL schema files as templates and adjust table names: \ud83d\udc49 Schema Files on GitHub</p>"},{"location":"features/processing/","title":"Processing Chain","text":"<p>Internal Processing Pipeline</p> <p>The library uses a Chain of Responsibility pattern to process outbox records through multiple stages. Each processor in the chain handles a specific concern and can delegate to the next processor when needed.</p>"},{"location":"features/processing/#chain-architecture","title":"Chain Architecture","text":"<p>The processing chain consists of four processors, executed in this exact order:</p> <pre><code>flowchart LR\n    A((Start)) --&gt; B[Invoke Handler]\n    B --&gt; C{Success?}\n\n    C -- Yes --&gt; Z[Mark COMPLETED]\n    C -- No --&gt; D{Can Retry?}\n\n    D -- Yes --&gt; E[Schedule Retry]\n\n    D -- No --&gt; F{Fallback Exists?}\n\n    F -- Yes --&gt; G[Invoke Fallback]\n    G --&gt; H{Fallback Success?}\n\n    H -- Yes --&gt; Z\n    H -- No --&gt; Y[Mark FAILED]\n\n    F -- No --&gt; Y\n\n    Y --&gt; S((Stop))\n    Z --&gt; S((Stop))</code></pre> <p>Processing Flow:</p> <ol> <li> <p>Primary Handler Processor - Invokes the registered handler for the payload type. On success, marks record as <code>COMPLETED</code>. On exception, passes to Retry Processor.</p> </li> <li> <p>Retry Processor - Evaluates if the exception is retryable and if retry limit is not exceeded. Schedules next retry with calculated delay or passes to Fallback Processor.</p> </li> <li> <p>Fallback Processor - Invokes registered fallback handler if available. On success, marks record as <code>COMPLETED</code>. On failure or if no fallback exists, passes to Permanent Failure Processor.</p> </li> <li> <p>Permanent Failure Processor - Marks the record as permanently <code>FAILED</code>. Final state - no further processing.</p> </li> </ol>"},{"location":"features/processing/#processing-flow-examples","title":"Processing Flow Examples","text":""},{"location":"features/processing/#scenario-1-retries-exhausted-with-successful-fallback","title":"Scenario 1: Retries Exhausted with Successful Fallback","text":"<p>Order processing with 3 max retries and fallback handler:</p> <pre><code>sequenceDiagram\n    participant S as Scheduler\n    participant P as Primary Processor\n    participant R as Retry Processor\n    participant F as Fallback Processor\n    participant DB as Database\n\n    Note over S,DB: Attempts 1-3: Retries\n    loop 3 times\n        S-&gt;&gt;P: Process Record\n        P-&gt;&gt;P: SocketTimeoutException\n        P-&gt;&gt;R: Handle Exception\n        R-&gt;&gt;R: Can Retry? \u2713\n        R-&gt;&gt;DB: Schedule Retry (1s\u21922s\u21924s)\n    end\n\n    Note over S,DB: Attempt 4: Fallback\n    S-&gt;&gt;P: Process Record\n    P-&gt;&gt;P: SocketTimeoutException\n    P-&gt;&gt;R: Handle Exception\n    R-&gt;&gt;R: Retries Exhausted\n    R-&gt;&gt;F: Invoke Fallback\n    F-&gt;&gt;F: Publish to DLQ\n    F-&gt;&gt;DB: Mark COMPLETED \u2713</code></pre>"},{"location":"features/processing/#scenario-2-non-retryable-exception","title":"Scenario 2: Non-Retryable Exception","text":"<p>Order processing with non-retryable exception:</p> <pre><code>sequenceDiagram\n    participant S as Scheduler\n    participant P as Primary Processor\n    participant R as Retry Processor\n    participant F as Fallback Processor\n    participant DB as Database\n\n    S-&gt;&gt;P: Process Record\n    P-&gt;&gt;P: IllegalArgumentException\n    P-&gt;&gt;R: Handle Exception\n    R-&gt;&gt;R: Non-Retryable Exception\n    R-&gt;&gt;F: Invoke Fallback\n    F-&gt;&gt;F: Publish to DLQ\n    F-&gt;&gt;DB: Mark COMPLETED \u2713</code></pre>"},{"location":"features/processing/#scenario-3-no-fallback-handler","title":"Scenario 3: No Fallback Handler","text":"<p>Order processing without fallback handler:</p> <pre><code>sequenceDiagram\n    participant S as Scheduler\n    participant P as Primary Processor\n    participant R as Retry Processor\n    participant F as Fallback Processor\n    participant PF as Permanent Failure Processor\n    participant DB as Database\n\n    Note over S,DB: Attempts 1-3: Retries\n    loop 3 times\n        S-&gt;&gt;P: Process Record\n        P-&gt;&gt;P: SocketTimeoutException\n        P-&gt;&gt;R: Handle Exception\n        R-&gt;&gt;R: Can Retry? \u2713\n        R-&gt;&gt;DB: Schedule Retry (1s\u21922s\u21924s)\n    end\n\n    Note over S,DB: Attempt 4: Permanent Failure\n    S-&gt;&gt;P: Process Record\n    P-&gt;&gt;P: SocketTimeoutException\n    P-&gt;&gt;R: Handle Exception\n    R-&gt;&gt;R: Retries Exhausted\n    R-&gt;&gt;F: Check Fallback\n    F-&gt;&gt;F: No Fallback Found\n    F-&gt;&gt;PF: Handle Permanent Failure\n    PF-&gt;&gt;DB: Mark FAILED \u2717</code></pre>"},{"location":"features/retry/","title":"Retry Mechanisms","text":"<p>The library provides sophisticated retry strategies to handle transient failures gracefully. You can configure a default retry policy for all handlers and optionally override it per handler.</p>"},{"location":"features/retry/#default-retry-policy","title":"Default Retry Policy","text":"<p>The default retry policy applies to all handlers unless overridden. Configure it via <code>application.yml</code> or by providing a custom <code>OutboxRetryPolicy</code> bean.</p>"},{"location":"features/retry/#built-in-retry-policies","title":"Built-in Retry Policies","text":""},{"location":"features/retry/#fixed-delay","title":"Fixed Delay","text":"<p>Retry with a constant delay between attempts:</p> <pre><code>namastack:\n  outbox:\n    retry:\n      policy: \"fixed\"\n      max-retries: 5\n      fixed:\n        delay: 5000  # 5 seconds between retries\n</code></pre> <p>Use Case: Simple scenarios with consistent retry intervals</p> <p>Example Retry Schedule: 0s \u2192 5s \u2192 5s \u2192 5s \u2192 5s \u2192 5s \u2192 Failed</p>"},{"location":"features/retry/#linear-backoff","title":"Linear Backoff","text":"<p>Retry with linearly increasing delays:</p> <pre><code>namastack:\n  outbox:\n    retry:\n      policy: \"linear\"\n      max-retries: 5\n      linear:\n        initial-delay: 2000    # Start with 2 seconds\n        increment: 2000        # Add 2 seconds each retry\n        max-delay: 60000       # Cap at 1 minute\n</code></pre> <p>Use Case: Gradually increasing delays for services that need time to recover</p> <p>Example Retry Schedule: 0s \u2192 2s \u2192 4s \u2192 6s \u2192 8s \u2192 10s \u2192 Failed</p>"},{"location":"features/retry/#exponential-backoff","title":"Exponential Backoff","text":"<p>Retry with exponentially increasing delays:</p> <pre><code>namastack:\n  outbox:\n    retry:\n      policy: \"exponential\"\n      max-retries: 3\n      exponential:\n        initial-delay: 1000    # Start with 1 second\n        max-delay: 60000       # Cap at 1 minute\n        multiplier: 2.0        # Double each time\n</code></pre> <p>Use Case: Handles transient failures gracefully without overwhelming downstream services</p> <p>Retry Schedule: 0s \u2192 1s \u2192 2s \u2192 4s \u2192 8s \u2192 16s \u2192 32s (capped at 60s)</p>"},{"location":"features/retry/#jittered-retry","title":"Jittered Retry","text":"<p>Add random jitter to prevent thundering herd problems. Jitter can be applied to any base policy (fixed, linear, or exponential):</p> <pre><code>namastack:\n  outbox:\n    retry:\n      policy: \"exponential\"  # Can also be \"fixed\" or \"linear\"\n      max-retries: 7\n      exponential:\n        initial-delay: 2000\n        max-delay: 60000\n        multiplier: 2.0\n      jitter: 1000  # Add [-1000ms, 1000ms] random delay\n</code></pre> <p>Benefits: Prevents coordinated retry storms when multiple instances retry simultaneously</p>"},{"location":"features/retry/#exception-filtering","title":"Exception Filtering","text":"<p>Exception-Based Retry Control (Since 1.0.0)</p> <p>Control which exceptions trigger retries using include/exclude patterns.</p> <p>Configure which exceptions should trigger retries:</p> <pre><code>namastack:\n  outbox:\n    retry:\n      policy: exponential\n      max-retries: 3\n      exponential:\n        initial-delay: 1000\n        max-delay: 60000\n        multiplier: 2.0\n      # Only retry these exceptions\n    include-exceptions:\n      - java.net.SocketTimeoutException\n      - org.springframework.web.client.ResourceAccessException\n      - java.io.IOException\n    # Never retry these exceptions\n    exclude-exceptions:\n      - java.lang.IllegalArgumentException\n      - javax.validation.ValidationException\n      - com.example.BusinessException\n</code></pre> <p>Rules:</p> <ul> <li>If <code>include-exceptions</code> is set, only listed exceptions are retryable</li> <li>If <code>exclude-exceptions</code> is set, listed exceptions are never retried</li> <li>If both are set, <code>exclude-exceptions</code> takes precedence</li> <li>If neither is set, all exceptions are retryable (default behavior)</li> </ul> <p>Use Cases:</p> <ul> <li>include-exceptions: Whitelist transient errors (network, timeout, rate limiting)</li> <li>exclude-exceptions: Blacklist permanent errors (validation, business rules, auth failures)</li> </ul>"},{"location":"features/retry/#custom-default-retry-policy","title":"Custom Default Retry Policy","text":"<p>Implement the <code>OutboxRetryPolicy</code> interface and register it as a bean named <code>outboxRetryPolicy</code>:</p> KotlinJava <pre><code>@Configuration\nclass OutboxConfig {\n    @Bean(\"outboxRetryPolicy\")\n    fun customRetryPolicy(): OutboxRetryPolicy {\n        return object : OutboxRetryPolicy {\n            override fun shouldRetry(exception: Throwable): Boolean {\n                // Don't retry validation errors\n                if (exception is IllegalArgumentException) return false\n\n                // Don't retry permanent failures\n                if (exception is PaymentDeclinedException) return false\n\n                // Retry transient failures\n                return exception is TimeoutException || \n                       exception is IOException ||\n                       exception.cause is TimeoutException\n            }\n\n            override fun nextDelay(failureCount: Int): Duration {\n                // Exponential backoff: 1s \u2192 2s \u2192 4s \u2192 8s (capped at 60s)\n                val delayMillis = 1000L * (1L shl failureCount)\n                return Duration.ofMillis(minOf(delayMillis, 60000L))\n            }\n\n            override fun maxRetries(): Int = 5\n        }\n    }\n}\n</code></pre> <pre><code>@Configuration\npublic class OutboxConfig {\n    @Bean(\"outboxRetryPolicy\")\n    public OutboxRetryPolicy customRetryPolicy() {\n        return new OutboxRetryPolicy() {\n            @Override\n            public boolean shouldRetry(Throwable exception) {\n                // Don't retry validation errors\n                if (exception instanceof IllegalArgumentException) return false;\n\n                // Don't retry permanent failures\n                if (exception instanceof PaymentDeclinedException) return false;\n\n                // Retry transient failures\n                return exception instanceof TimeoutException || \n                       exception instanceof IOException ||\n                       (exception.getCause() instanceof TimeoutException);\n            }\n\n            @Override\n            public Duration nextDelay(int failureCount) {\n                // Exponential backoff: 1s \u2192 2s \u2192 4s \u2192 8s (capped at 60s)\n                long delayMillis = 1000L * (1L &lt;&lt; failureCount);\n                return Duration.ofMillis(Math.min(delayMillis, 60000L));\n            }\n\n            @Override\n            public int maxRetries() {\n                return 5;\n            }\n        };\n    }\n}\n</code></pre> <p>Key Methods:</p> <ul> <li><code>shouldRetry(exception: Throwable): Boolean</code> - Decide if this error should be retried</li> <li><code>nextDelay(failureCount: Int): Duration</code> - Calculate delay before next retry</li> <li><code>maxRetries(): Int</code> - Maximum number of retry attempts</li> </ul> <p>Important: The bean must be named <code>outboxRetryPolicy</code> to override the default policy configured in <code>application.yml</code>.</p>"},{"location":"features/retry/#handler-specific-retry-policies","title":"Handler-Specific Retry Policies","text":"<p>Per-Handler Retry Configuration (Since 1.0.0)</p> <p>Override the default retry policy for specific handlers using <code>@OutboxRetryable</code> annotation or by implementing the <code>OutboxRetryAware</code> interface.</p> <p>You can configure retry behavior per handler, allowing different handlers to have different retry strategies.</p>"},{"location":"features/retry/#interface-based-approach","title":"Interface-Based Approach","text":"<p>Implement the <code>OutboxRetryAware</code> interface to specify a retry policy programmatically:</p> KotlinJava <pre><code>@Component\nclass PaymentHandler(\n    private val aggressiveRetryPolicy: AggressiveRetryPolicy\n) : OutboxTypedHandler&lt;PaymentEvent&gt;, OutboxRetryAware {\n\n    override fun handle(payload: PaymentEvent, metadata: OutboxRecordMetadata) {\n        paymentGateway.process(payload)\n    }\n\n    override fun getRetryPolicy(): OutboxRetryPolicy = aggressiveRetryPolicy\n}\n\n@Component\nclass NotificationHandler(\n    private val conservativeRetryPolicy: ConservativeRetryPolicy\n) : OutboxTypedHandler&lt;NotificationEvent&gt;, OutboxRetryAware {\n\n    override fun handle(payload: NotificationEvent, metadata: OutboxRecordMetadata) {\n        emailService.send(payload)\n    }\n\n    override fun getRetryPolicy(): OutboxRetryPolicy = conservativeRetryPolicy\n}\n\n@Component\nclass AggressiveRetryPolicy : OutboxRetryPolicy {\n    override fun shouldRetry(exception: Throwable) = true\n    override fun nextDelay(failureCount: Int) = Duration.ofMillis(500)\n    override fun maxRetries() = 10\n}\n\n@Component\nclass ConservativeRetryPolicy : OutboxRetryPolicy {\n    override fun shouldRetry(exception: Throwable) = \n        exception !is IllegalArgumentException\n    override fun nextDelay(failureCount: Int) = Duration.ofSeconds(10)\n    override fun maxRetries() = 2\n}\n</code></pre> <pre><code>@Component\npublic class PaymentHandler implements OutboxTypedHandler&lt;PaymentEvent&gt;, OutboxRetryAware {\n    private final AggressiveRetryPolicy aggressiveRetryPolicy;\n\n    public PaymentHandler(AggressiveRetryPolicy aggressiveRetryPolicy) {\n        this.aggressiveRetryPolicy = aggressiveRetryPolicy;\n    }\n\n    @Override\n    public void handle(PaymentEvent payload, OutboxRecordMetadata metadata) {\n        paymentGateway.process(payload);\n    }\n\n    @Override\n    public OutboxRetryPolicy getRetryPolicy() {\n        return aggressiveRetryPolicy;\n    }\n}\n\n@Component\npublic class NotificationHandler implements OutboxTypedHandler&lt;NotificationEvent&gt;, OutboxRetryAware {\n    private final ConservativeRetryPolicy conservativeRetryPolicy;\n\n    public NotificationHandler(ConservativeRetryPolicy conservativeRetryPolicy) {\n        this.conservativeRetryPolicy = conservativeRetryPolicy;\n    }\n\n    @Override\n    public void handle(NotificationEvent payload, OutboxRecordMetadata metadata) {\n        emailService.send(payload);\n    }\n\n    @Override\n    public OutboxRetryPolicy getRetryPolicy() {\n        return conservativeRetryPolicy;\n    }\n}\n\n@Component\npublic class AggressiveRetryPolicy implements OutboxRetryPolicy {\n    @Override\n    public boolean shouldRetry(Throwable exception) {\n        return true;\n    }\n\n    @Override\n    public Duration nextDelay(int failureCount) {\n        return Duration.ofMillis(500);\n    }\n\n    @Override\n    public int maxRetries() {\n        return 10;\n    }\n}\n\n@Component\npublic class ConservativeRetryPolicy implements OutboxRetryPolicy {\n    @Override\n    public boolean shouldRetry(Throwable exception) {\n        return !(exception instanceof IllegalArgumentException);\n    }\n\n    @Override\n    public Duration nextDelay(int failureCount) {\n        return Duration.ofSeconds(10);\n    }\n\n    @Override\n    public int maxRetries() {\n        return 2;\n    }\n}\n</code></pre>"},{"location":"features/retry/#annotation-based-approach","title":"Annotation-Based Approach","text":"<p>Use the <code>@OutboxRetryable</code> annotation for method-level retry policy configuration:</p> KotlinJava <pre><code>@Component\nclass PaymentHandler {\n    // Critical handler - aggressive retries\n    @OutboxHandler\n    @OutboxRetryable(AggressiveRetryPolicy::class)\n    fun handlePayment(payload: PaymentEvent) {\n        paymentGateway.process(payload)\n    }\n\n    // Less critical handler - conservative retries\n    @OutboxHandler\n    @OutboxRetryable(ConservativeRetryPolicy::class)\n    fun handleNotification(payload: NotificationEvent) {\n        emailService.send(payload)\n    }\n\n    // Uses default retry policy\n    @OutboxHandler\n    fun handleAudit(payload: AuditEvent) {\n        auditService.log(payload)\n    }\n}\n</code></pre> <pre><code>@Component\npublic class PaymentHandler {\n    // Critical handler - aggressive retries\n    @OutboxHandler\n    @OutboxRetryable(AggressiveRetryPolicy.class)\n    public void handlePayment(PaymentEvent payload) {\n        paymentGateway.process(payload);\n    }\n\n    // Less critical handler - conservative retries\n    @OutboxHandler\n    @OutboxRetryable(ConservativeRetryPolicy.class)\n    public void handleNotification(NotificationEvent payload) {\n        emailService.send(payload);\n    }\n\n    // Uses default retry policy\n    @OutboxHandler\n    public void handleAudit(AuditEvent payload) {\n        auditService.log(payload);\n    }\n}\n</code></pre> <p>Policy Resolution Order:</p> <ol> <li>Handler-specific policy via interface (<code>OutboxRetryAware.getRetryPolicy()</code>) - highest priority</li> <li>Handler-specific policy via annotation (<code>@OutboxRetryable</code>)</li> <li>Global custom policy (bean named <code>outboxRetryPolicy</code>)</li> <li>Default policy (from <code>application.yml</code>)</li> </ol> <p>Interface vs Annotation</p> <ul> <li>Interface (<code>OutboxRetryAware</code>): Best when handler class is dedicated to single payload type, and you want type safety</li> <li>Annotation (<code>@OutboxRetryable</code>): Best for method-level handlers or multiple handlers in one class</li> </ul>"},{"location":"features/retry/#outboxretrypolicybuilder-api","title":"OutboxRetryPolicy.Builder API","text":"<p>Use the fluent builder to compose robust retry policies without implementing the interface yourself.</p> KotlinJava <pre><code>@Configuration\nclass OutboxConfig {\n    @Bean\n    fun customRetryPolicy(): OutboxRetryPolicy {\n        return OutboxRetryPolicy.builder()\n            .maxRetries(5)\n            .exponentialBackoff(\n                initialDelay = Duration.ofSeconds(10),\n                multiplier = 2.0,\n                maxDelay = Duration.ofMinutes(5)\n            )\n            .jitter(Duration.ofSeconds(2))\n            .retryOn(TimeoutException::class.java, IOException::class.java)\n            .noRetryOn(IllegalArgumentException::class.java)\n            .build()\n    }\n}\n</code></pre> <pre><code>@Configuration\npublic class OutboxConfig {\n    @Bean\n    public OutboxRetryPolicy customRetryPolicy() {\n        return OutboxRetryPolicy.builder()\n            .maxRetries(5)\n            .exponentialBackoff(\n                Duration.ofSeconds(10),\n                2.0,\n                Duration.ofMinutes(5)\n            )\n            .jitter(Duration.ofSeconds(2))\n            .retryOn(TimeoutException.class, IOException.class)\n            .noRetryOn(IllegalArgumentException.class)\n            .build();\n    }\n}\n</code></pre> <p>Builder at a glance:</p> <ul> <li>Defaults: maxRetries = 3, fixedBackOff = 5s, jitter = 0, retry on all exceptions</li> <li>Immutability: each method returns a new Builder; the original instance isn't mutated</li> <li>Validation: durations must be &gt; 0 (except jitter, which can be 0), multiplier &gt; 1.0</li> </ul>"},{"location":"features/retry/#using-the-autoconfigured-builder","title":"Using the autoconfigured Builder","text":"<p>A bean named <code>outboxRetryPolicyBuilder</code> is auto-configured from your <code>namastack.outbox.retry.*</code> application properties. Inject it to retain property-driven defaults and add programmatic customizations.</p> KotlinJava <pre><code>@Configuration\nclass OutboxConfig {\n    // Inject the autoconfigured builder from application.yml\n    @Bean\n    fun customRetryPolicy(\n        builder: OutboxRetryPolicy.Builder\n    ): OutboxRetryPolicy {\n        // Start from property-based defaults, then refine\n        return builder\n            .retryOn(TimeoutException::class.java, IOException::class.java)\n            .noRetryOn(IllegalArgumentException::class.java)\n            .build()\n    }\n}\n</code></pre> <pre><code>@Configuration\npublic class OutboxConfig {\n    // Inject the autoconfigured builder from application.yml\n    @Bean\n    public OutboxRetryPolicy customRetryPolicy(\n        OutboxRetryPolicy.Builder builder\n    ) {\n        // Start from property-based defaults, then refine\n        return builder\n            .retryOn(TimeoutException.class, IOException.class)\n            .noRetryOn(IllegalArgumentException.class)\n            .build();\n    }\n}\n</code></pre>"},{"location":"features/retry/#builder-configuration-options","title":"Builder configuration options","text":"<p>Backoff strategies:</p> <ul> <li> <p>Fixed: same delay for all retries <code>fixedBackOff(Duration.ofSeconds(30))</code></p> </li> <li> <p>Linear: incrementally increasing delay <code>linearBackoff(initialDelay = Duration.ofSeconds(5), increment = Duration.ofSeconds(5), maxDelay = Duration.ofMinutes(2))</code></p> </li> <li> <p>Exponential: exponentially increasing delay <code>exponentialBackoff(initialDelay = Duration.ofSeconds(10), multiplier = 2.0, maxDelay = Duration.ofMinutes(5))</code></p> </li> <li> <p>Custom: provide your own strategy <code>backOff(myCustomBackOffStrategy)</code></p> </li> </ul> <p>Jitter:</p> <p>Jitter randomizes the computed delay within [base - jitter, base + jitter] to avoid thundering herds; delays never go below zero.</p> <pre><code>OutboxRetryPolicy.builder()\n    .fixedBackOff(Duration.ofSeconds(30))\n    .jitter(Duration.ofSeconds(5))  // Actual delay: ~25-35 seconds\n</code></pre> <p>Exception rules and priority:</p> <ul> <li>noRetryOn(): these exceptions are never retried (highest priority)</li> <li>retryOn(): if specified, only these exceptions (or subclasses) are retried</li> <li>retryIf(): predicate for advanced logic</li> <li>Default: if neither retryOn() nor retryIf() is configured, all exceptions are retried; if any rule is configured but none match, do not retry</li> </ul> KotlinJava <pre><code>// Retry only on specific exceptions\nOutboxRetryPolicy.builder()\n    .retryOn(TimeoutException::class.java, IOException::class.java)\n    .build()\n\n// Retry all except specific exceptions\nOutboxRetryPolicy.builder()\n    .noRetryOn(IllegalArgumentException::class.java, PaymentDeclinedException::class.java)\n    .build()\n\n// Custom predicate for complex logic\nOutboxRetryPolicy.builder()\n    .retryIf { exception -&gt;\n        exception is RetryableException ||\n        (exception.cause is TimeoutException)\n    }\n    .build()\n\n// Combine multiple rules (noRetryOn takes precedence)\nOutboxRetryPolicy.builder()\n    .retryOn(IOException::class.java)\n    .noRetryOn(FileNotFoundException::class.java)\n    .retryIf { exception -&gt; exception.message?.contains(\"transient\") == true }\n    .build()\n</code></pre> <pre><code>// Retry only on specific exceptions\nOutboxRetryPolicy.builder()\n    .retryOn(TimeoutException.class, IOException.class)\n    .build();\n\n// Retry all except specific exceptions\nOutboxRetryPolicy.builder()\n    .noRetryOn(IllegalArgumentException.class, PaymentDeclinedException.class)\n    .build();\n\n// Custom predicate for complex logic\nOutboxRetryPolicy.builder()\n    .retryIf(exception -&gt;\n        exception instanceof RetryableException ||\n        (exception.getCause() instanceof TimeoutException)\n    )\n    .build();\n\n// Combine multiple rules (noRetryOn takes precedence)\nOutboxRetryPolicy.builder()\n    .retryOn(IOException.class)\n    .noRetryOn(FileNotFoundException.class)\n    .retryIf(exception -&gt;\n        exception.getMessage() != null &amp;&amp;\n        exception.getMessage().contains(\"transient\")\n    )\n    .build();\n</code></pre>"},{"location":"features/retry/#complete-examples","title":"Complete examples","text":"KotlinJava <pre><code>// Simple policy with exponential backoff\nval simplePolicy = OutboxRetryPolicy.builder()\n    .maxRetries(5)\n    .exponentialBackoff(\n        initialDelay = Duration.ofSeconds(10),\n        multiplier = 2.0,\n        maxDelay = Duration.ofMinutes(5)\n    )\n    .build()\n\n// Advanced policy with all features\nval advancedPolicy = OutboxRetryPolicy.builder()\n    .maxRetries(10)\n    .linearBackoff(\n        initialDelay = Duration.ofSeconds(5),\n        increment = Duration.ofSeconds(5),\n        maxDelay = Duration.ofMinutes(2)\n    )\n    .jitter(Duration.ofSeconds(2))\n    .retryOn(TimeoutException::class.java, IOException::class.java)\n    .noRetryOn(IllegalArgumentException::class.java)\n    .retryIf { exception -&gt;\n        exception.message?.contains(\"retry\", ignoreCase = true) == true\n    }\n    .build()\n</code></pre> <pre><code>// Simple policy with exponential backoff\nOutboxRetryPolicy simplePolicy = OutboxRetryPolicy.builder()\n    .maxRetries(5)\n    .exponentialBackoff(\n        Duration.ofSeconds(10),\n        2.0,\n        Duration.ofMinutes(5)\n    )\n    .build();\n\n// Advanced policy with all features\nOutboxRetryPolicy advancedPolicy = OutboxRetryPolicy.builder()\n    .maxRetries(10)\n    .linearBackoff(\n        Duration.ofSeconds(5),\n        Duration.ofSeconds(5),\n        Duration.ofMinutes(2)\n    )\n    .jitter(Duration.ofSeconds(2))\n    .retryOn(TimeoutException.class, IOException.class)\n    .noRetryOn(IllegalArgumentException.class)\n    .retryIf(exception -&gt;\n        exception.getMessage() != null &amp;&amp;\n        exception.getMessage().toLowerCase().contains(\"retry\")\n    )\n    .build();\n</code></pre>"},{"location":"features/scheduling/","title":"Record Scheduling","text":""},{"location":"features/scheduling/#outbox-service-api","title":"Outbox Service API","text":"<p>Schedule records for processing via the <code>Outbox</code> service:</p> KotlinJava <pre><code>@Service\nclass OrderService(\n    private val outbox: Outbox,\n    private val orderRepository: OrderRepository\n) {\n    @Transactional\n    fun createOrder(command: CreateOrderCommand) {\n        val order = Order.create(command)\n        orderRepository.save(order)\n\n        // Schedule record with explicit key\n        outbox.schedule(\n            payload = OrderCreatedRecord(order.id, order.customerId),\n            key = \"order-${order.id}\"  // Groups records for ordered processing\n        )\n    }\n\n    @Transactional\n    fun updateOrder(orderId: String) {\n        // Schedule record with auto-generated UUID key\n        outbox.schedule(payload = OrderUpdatedRecord(orderId))\n    }\n}\n</code></pre> <pre><code>@Service\npublic class OrderService {\n    private final Outbox outbox;\n    private final OrderRepository orderRepository;\n\n    public OrderService(Outbox outbox, OrderRepository orderRepository) {\n        this.outbox = outbox;\n        this.orderRepository = orderRepository;\n    }\n\n    @Transactional\n    public void createOrder(CreateOrderCommand command) {\n        Order order = Order.create(command);\n        orderRepository.save(order);\n\n        // Schedule record with explicit key\n        outbox.schedule(\n            new OrderCreatedRecord(order.getId(), order.getCustomerId()),\n            \"order-\" + order.getId()  // Groups records for ordered processing\n        );\n    }\n\n    @Transactional\n    public void updateOrder(String orderId) {\n        // Schedule record with auto-generated UUID key\n        outbox.schedule(new OrderUpdatedRecord(orderId));\n    }\n}\n</code></pre>"},{"location":"features/scheduling/#record-lifecycle","title":"Record Lifecycle","text":"<p>Records go through the following states:</p> <ul> <li>NEW: Freshly scheduled, waiting for processing</li> <li>COMPLETED: Successfully processed by all handlers</li> <li>FAILED: Exhausted all retries, requires manual intervention</li> </ul>"},{"location":"features/scheduling/#outboxeventmulticaster","title":"OutboxEventMulticaster","text":"<p>The <code>OutboxEventMulticaster</code> provides seamless integration with Spring's event system. It automatically intercepts and persists events annotated with <code>@OutboxEvent</code> directly to the outbox table, allowing you to use Spring's native <code>ApplicationEventPublisher</code> while getting outbox benefits.</p>"},{"location":"features/scheduling/#how-it-works","title":"How It Works","text":"<pre><code>graph TB\n    A[\"publishEvent(event)\"] --&gt; B[\"OutboxEventMulticaster\"]\n    B --&gt; C{Check OutboxEvent&lt;br/&gt;Annotation}\n    C --&gt;|Present| D[\"Serialize &amp; Store\"]\n    C --&gt;|Not Present| E[\"Normal Event Flow\"]\n    D --&gt; F[\"Outbox Table\"]\n    E --&gt; G[\"Event Listeners\"]\n    D --&gt;|if publish-after-save=true| G</code></pre>"},{"location":"features/scheduling/#outboxevent-annotation","title":"@OutboxEvent Annotation","text":"<p>Mark your events with <code>@OutboxEvent</code> to enable automatic outbox persistence:</p> KotlinJava <pre><code>@OutboxEvent(key = \"#event.orderId\")  // SpEL expression for key resolution\ndata class OrderCreatedEvent(\n    val orderId: String,\n    val customerId: String,\n    val amount: BigDecimal\n)\n</code></pre> <pre><code>@OutboxEvent(key = \"#event.orderId\")  // SpEL expression for key resolution\npublic class OrderCreatedEvent {\n    private String orderId;\n    private String customerId;\n    private BigDecimal amount;\n\n    // constructor, getters, setters...\n}\n</code></pre>"},{"location":"features/scheduling/#spel-key-resolution","title":"SpEL Key Resolution","text":"<p>The <code>key</code> parameter supports Spring Expression Language (SpEL) for dynamic key extraction:</p> Expression Description Example <code>#root.fieldName</code> Access root object property <code>#root.orderId</code> <code>#event.fieldName</code> Same as #root (alternative syntax) <code>#event.customerId</code> <code>#root.getId()</code> Call method on root object <code>#root.getOrderId()</code> <code>#root.nested.field</code> Access nested properties <code>#root.order.id</code> <code>#root.toString()</code> Convert to string <code>#root.id.toString()</code> <p>SpEL Examples</p> Simple PropertyMethod CallNested Property <pre><code>@OutboxEvent(key = \"#event.orderId\")\ndata class OrderEvent(val orderId: String)\n</code></pre> <pre><code>@OutboxEvent(key = \"#event.getAggregateId()\")\ndata class DomainEvent(val id: UUID) {\n    fun getAggregateId() = id.toString()\n}\n</code></pre> <pre><code>@OutboxEvent(key = \"#event.order.id\")\ndata class OrderConfirmedEvent(val order: Order)\n</code></pre>"},{"location":"features/scheduling/#configuration","title":"Configuration","text":"<p>The multicaster can be configured to control event publishing behavior:</p> <pre><code>namastack:\n  outbox:\n    multicaster:\n      enabled: true  # Enable/disable automatic interception (default: true)\n\n    processing:\n      publish-after-save: true  # Also forward to other listeners in same transaction (default: true)\n</code></pre> Configuration Value Effect <code>multicaster.enabled</code> <code>true</code> (default) @OutboxEvent annotations are intercepted and stored <code>multicaster.enabled</code> <code>false</code> OutboxEventMulticaster is disabled, events flow normally <code>publish-after-save</code> <code>true</code> (default) Events also published to other listeners in same transaction <code>publish-after-save</code> <code>false</code> Events only stored to outbox, not published to listeners"},{"location":"features/scheduling/#usage-example","title":"Usage Example","text":"KotlinJava <pre><code>@Service\nclass OrderService(\n    private val orderRepository: OrderRepository,\n    private val eventPublisher: ApplicationEventPublisher\n) {\n    @Transactional\n    fun createOrder(command: CreateOrderCommand) {\n        val order = Order.create(command)\n        orderRepository.save(order)\n\n        // Automatically saved to outbox + published to listeners\n        eventPublisher.publishEvent(\n            OrderCreatedEvent(order.id, order.customerId, order.amount)\n        )\n    }\n}\n</code></pre> <pre><code>@Service\npublic class OrderService {\n    private final OrderRepository orderRepository;\n    private final ApplicationEventPublisher eventPublisher;\n\n    public OrderService(OrderRepository orderRepository, \n                       ApplicationEventPublisher eventPublisher) {\n        this.orderRepository = orderRepository;\n        this.eventPublisher = eventPublisher;\n    }\n\n    @Transactional\n    public void createOrder(CreateOrderCommand command) {\n        Order order = Order.create(command);\n        orderRepository.save(order);\n\n        // Automatically saved to outbox + published to listeners\n        eventPublisher.publishEvent(\n            new OrderCreatedEvent(order.getId(), order.getCustomerId(), order.getAmount())\n        );\n    }\n}\n</code></pre>"},{"location":"features/scheduling/#outboxevent-with-context","title":"@OutboxEvent with Context","text":"<p>When using <code>@OutboxEvent</code> with <code>ApplicationEventPublisher</code>, you can define context using SpEL expressions:</p> KotlinJava <pre><code>@OutboxEvent(\n    key = \"#this.orderId\",\n    context = [\n        OutboxContextEntry(key = \"customerId\", value = \"#this.customerId\"),\n        OutboxContextEntry(key = \"region\", value = \"#this.region\"),\n        OutboxContextEntry(key = \"priority\", value = \"#this.priority\")\n    ]\n)\ndata class OrderCreatedEvent(\n    val orderId: String,\n    val customerId: String,\n    val region: String,\n    val priority: String\n)\n</code></pre> <pre><code>@OutboxEvent(\n    key = \"#this.orderId\",\n    context = {\n        @OutboxContextEntry(key = \"customerId\", value = \"#this.customerId\"),\n        @OutboxContextEntry(key = \"region\", value = \"#this.region\"),\n        @OutboxContextEntry(key = \"priority\", value = \"#this.priority\")\n    }\n)\npublic class OrderCreatedEvent {\n    private String orderId;\n    private String customerId;\n    private String region;\n    private String priority;\n    // constructor, getters...\n}\n</code></pre> <p>Context from <code>@OutboxEvent</code> annotations is merged with context from registered <code>OutboxContextProvider</code> beans.</p>"},{"location":"features/serialization/","title":"Payload Serialization","text":"<p>Records are serialized before storage and deserialized during processing. The library provides flexible serialization through the <code>OutboxPayloadSerializer</code> interface.</p>"},{"location":"features/serialization/#jackson-module-default","title":"Jackson Module (Default)","text":"<p>The <code>namastack-outbox-jackson</code> module provides default JSON serialization using Jackson 3.x:</p> <pre><code>dependencies {\n  implementation(\"io.namastack:namastack-outbox-starter-jpa:1.0.0\")  # Includes Jackson by default\n}\n</code></pre> <p>Supported Features:</p> <ul> <li>JSON serialization/deserialization</li> <li>Custom Jackson modules and mixins</li> <li>Standard Jackson configuration via <code>spring.jackson.*</code> properties</li> </ul> <p>Example Jackson Configuration:</p> <pre><code>spring:\n  jackson:\n    default-property-inclusion: NON_NULL\n    serialization:\n      write-dates-as-timestamps: false\n      indent-output: true\n    deserialization:\n      fail-on-unknown-properties: false\n</code></pre>"},{"location":"features/serialization/#outboxpayloadserializer-interface","title":"OutboxPayloadSerializer Interface","text":"<p>Implement custom serializers for alternative formats (Protobuf, Avro, XML, etc.):</p> KotlinJava <pre><code>interface OutboxPayloadSerializer {\n    fun serialize(payload: Any): String\n    fun &lt;T&gt; deserialize(data: String, targetType: Class&lt;T&gt;): T\n}\n</code></pre> <pre><code>public interface OutboxPayloadSerializer {\n    String serialize(Object payload);\n    &lt;T&gt; T deserialize(String data, Class&lt;T&gt; targetType);\n}\n</code></pre>"},{"location":"features/serialization/#custom-serializer-implementation","title":"Custom Serializer Implementation","text":"Kotlin - Protocol Buffers ExampleJava - Protocol Buffers Example <pre><code>@Configuration\nclass OutboxSerializationConfig {\n    @Bean\n    fun protobufSerializer(): OutboxPayloadSerializer {\n        return object : OutboxPayloadSerializer {\n            override fun serialize(payload: Any): String {\n                // Implement Protobuf serialization\n                require(payload is Message) { \"Payload must be Protobuf Message\" }\n                return Base64.encoder.encodeToString(payload.toByteArray())\n            }\n\n            override fun &lt;T&gt; deserialize(data: String, targetType: Class&lt;T&gt;): T {\n                // Implement Protobuf deserialization\n                val bytes = Base64.decoder.decode(data)\n                val method = targetType.getMethod(\"parseFrom\", ByteArray::class.java)\n                @Suppress(\"UNCHECKED_CAST\")\n                return method.invoke(null, bytes) as T\n            }\n        }\n    }\n}\n</code></pre> <pre><code>@Configuration\npublic class OutboxSerializationConfig {\n    @Bean\n    public OutboxPayloadSerializer protobufSerializer() {\n        return new OutboxPayloadSerializer() {\n            @Override\n            public String serialize(Object payload) {\n                if (!(payload instanceof Message)) {\n                    throw new IllegalArgumentException(\"Payload must be Protobuf Message\");\n                }\n                byte[] bytes = ((Message) payload).toByteArray();\n                return Base64.getEncoder().encodeToString(bytes);\n            }\n\n            @Override\n            public &lt;T&gt; T deserialize(String data, Class&lt;T&gt; targetType) {\n                try {\n                    byte[] bytes = Base64.getDecoder().decode(data);\n                    java.lang.reflect.Method method = targetType.getMethod(\"parseFrom\", byte[].class);\n                    return (T) method.invoke(null, bytes);\n                } catch (Exception e) {\n                    throw new RuntimeException(e);\n                }\n            }\n        };\n    }\n}\n</code></pre> <p>Important: When you provide a custom serializer as a Spring bean, it automatically replaces the default Jackson serializer.</p>"},{"location":"features/virtual-threads/","title":"Virtual Threads Support","text":"<p>When virtual threads are enabled in Spring Boot, Namastack Outbox automatically uses virtual threads for outbox processing, providing better scalability for I/O-bound workloads.</p>"},{"location":"features/virtual-threads/#enabling-virtual-threads","title":"Enabling Virtual Threads","text":"<p>Enable virtual threads in your Spring Boot application:</p> <pre><code>spring:\n  threads:\n    virtual:\n      enabled: true\n</code></pre> <p>Benefits:</p> <ul> <li>Higher Throughput: Handle more concurrent outbox records with fewer resources</li> <li>Lower Memory: Virtual threads have minimal memory overhead</li> <li>Better I/O Handling: Ideal for handlers that make external API calls</li> <li>Automatic: No code changes required - the library detects and uses virtual threads automatically</li> </ul>"},{"location":"features/virtual-threads/#configuration","title":"Configuration","text":"<p>When virtual threads are enabled, use the concurrency limit instead of pool sizes:</p> <pre><code>namastack:\n  outbox:\n    processing:\n      executor-concurrency-limit: -1           # -1 for unlimited, or set a specific limit\n</code></pre> <p>Platform Threads</p> <p>When virtual threads are disabled (default), the library uses traditional thread pools: <pre><code>namastack:\n  outbox:\n    processing:\n      executor-core-pool-size: 4\n      executor-max-pool-size: 8\n</code></pre></p>"}]}